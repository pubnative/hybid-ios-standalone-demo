// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1 effective-5.10 (swiftlang-6.1.0.110.21 clang-1700.0.13.3)
// swift-module-flags: -target arm64-apple-ios12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Osize -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name ATOM
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -interface-compiler-version 6.1
@_exported import ATOM
import AdSupport
import AppTrackingTransparency
import CoreGraphics
import CoreML
import CoreMotion
import CoreTelephony
import Dispatch
import Foundation
import Network
import SQLite3
import Swift
import SystemConfiguration
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os
@_hasMissingDesignatedInitializers final public class ATOMDBGestureQueries {
  @objc deinit
}
public typealias SQLiteConnection = Swift.OpaquePointer
@_hasMissingDesignatedInitializers final public class Database {
  final public let sqliteConnection: SQLiteConnection
  public static var logError: Database.LogErrorFunction? {
    get
    set
  }
  final public let configuration: Configuration
  final public var lastInsertedRowID: Swift.Int64 {
    get
  }
  final public var changesCount: Swift.Int {
    get
  }
  final public var totalChangesCount: Swift.Int {
    get
  }
  final public var isInsideTransaction: Swift.Bool {
    get
  }
  final public var lastErrorCode: ResultCode {
    get
  }
  final public var lastErrorMessage: Swift.String? {
    get
  }
  @objc deinit
  public static let suspendNotification: Foundation.Notification.Name
  public static let resumeNotification: Foundation.Notification.Name
  final public func inTransaction(_ kind: Database.TransactionKind? = nil, _ block: () throws -> Database.TransactionCompletion) throws
  final public func inSavepoint(_ block: () throws -> Database.TransactionCompletion) throws
  final public func beginTransaction(_ kind: Database.TransactionKind? = nil) throws
  final public func rollback() throws
  final public func commit() throws
}
extension Database {
  public typealias BusyCallback = (_ numberOfTries: Swift.Int) -> Swift.Bool
  public enum BusyMode {
    case immediateError
    case timeout(Foundation.TimeInterval)
    case callback(Database.BusyCallback)
  }
  public enum CheckpointMode : Swift.Int32 {
    case passive
    case full
    case restart
    case truncate
    public init?(rawValue: Swift.Int32)
    public typealias RawValue = Swift.Int32
    public var rawValue: Swift.Int32 {
      get
    }
  }
  public struct CollationName : Swift.RawRepresentable, Swift.Hashable {
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public init(_ rawValue: Swift.String)
    public static let binary: Database.CollationName
    public static let nocase: Database.CollationName
    public static let rtrim: Database.CollationName
    public typealias RawValue = Swift.String
  }
  public struct ColumnType : Swift.RawRepresentable, Swift.Hashable {
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public init(_ rawValue: Swift.String)
    public static let text: Database.ColumnType
    public static let integer: Database.ColumnType
    public static let double: Database.ColumnType
    public static let numeric: Database.ColumnType
    public static let boolean: Database.ColumnType
    public static let blob: Database.ColumnType
    public static let date: Database.ColumnType
    public static let datetime: Database.ColumnType
    public typealias RawValue = Swift.String
  }
  public enum ConflictResolution : Swift.String {
    case rollback
    case abort
    case fail
    case ignore
    case replace
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ForeignKeyAction : Swift.String {
    case cascade
    case restrict
    case setNull
    case setDefault
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public typealias LogErrorFunction = (_ resultCode: ResultCode, _ message: Swift.String) -> Swift.Void
  public enum TransactionCompletion {
    case commit
    case rollback
    public static func == (a: Database.TransactionCompletion, b: Database.TransactionCompletion) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum TransactionKind : Swift.String {
    case deferred
    case immediate
    case exclusive
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension CoreFoundation.CGFloat : DatabaseValueConvertible {
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> CoreFoundation.CGFloat?
}
public struct ATOMSwipeTick : Swift.Equatable {
  public static func == (lhs: ATOMSwipeTick, rhs: ATOMSwipeTick) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class ATOMConsentDataParser {
  public static func parse(consentString: Swift.String) throws -> Foundation.Data
  @objc deinit
}
final public class ATOMTCFConsentValidator {
  final public var maxVendorIdForConsents: ATOMVendorIdentifier {
    get
  }
  public init(consentData: Foundation.Data) throws
  final public func isVendorAllowed(vendorID: ATOMVendorIdentifier) -> Swift.Bool
  final public func isPurposeConsentAllowed(_ purposeId: ATOMPurposeIdentifier) -> Swift.Bool
  @objc deinit
}
final public class ATOMTCFConsent {
  public init(withConsentString consentString: Swift.String) throws
  final public func isVendorAllowed(_ vendorId: ATOMVendorIdentifier) -> Swift.Bool
  final public func isPurposeAllowed(_ purposeId: ATOMPurposeIdentifier) -> Swift.Bool
  final public func arePurposesAllowed(_ purposeIds: [ATOMPurposeIdentifier]) -> Swift.Bool
  @objc deinit
}
public protocol ATOMConsentChecker {
  func isSubjectToLocationAware() -> Swift.Bool
}
public class ATOMGDPRConsentChecker : ATOMConsentChecker {
  public init()
  public func isSubjectToLocationAware() -> Swift.Bool
  @objc deinit
}
public class ATOMCCPAConsentChecker : ATOMConsentChecker {
  public init()
  public func isSubjectToLocationAware() -> Swift.Bool
  @objc deinit
}
final public class ATOMConsentSDK {
  public init(gdprConsentChecker: any ATOMConsentChecker = ATOMGDPRConsentChecker(), ccpaConsentChecker: any ATOMConsentChecker = ATOMCCPAConsentChecker())
  public init(withCustomTCFString tcfString: Swift.String, gdprConsentChecker: any ATOMConsentChecker = ATOMGDPRConsentChecker()) throws
  public init(withCustomCCPAString ccpaString: Swift.String, ccpaConsentChecker: any ATOMConsentChecker = ATOMCCPAConsentChecker()) throws
  final public func isSubjectToGDPR() -> Swift.Bool
  final public func isSubjectToCCPA() -> Swift.Bool
  final public func isSubjectToRegulation() -> Swift.Bool
  final public func refreshConsent() throws
  public static func isSubjectToGDPR(checker: (any ATOMConsentChecker)? = nil) -> Swift.Bool
  public static func isSubjectToCCPA(checker: (any ATOMConsentChecker)? = nil) -> Swift.Bool
  final public func isVendorAllowed(_ vendorID: ATOMVendorIdentifier) throws -> Swift.Bool
  final public func isPurposeAllowed(_ purposeID: ATOMPurposeIdentifier) throws -> Swift.Bool
  final public func arePurposesAllowed(_ purposesID: [ATOMPurposeIdentifier]) throws -> Swift.Bool
  final public func isSaleAllowed() throws -> Swift.Bool
  final public func isTrackingAllowed(vendorID: ATOMVendorIdentifier, purposeIDs: [ATOMPurposeIdentifier]) throws -> Swift.Bool
  @objc deinit
}
public typealias ATOMVendorIdentifier = Swift.Int32
public typealias ATOMPurposeIdentifier = Swift.Int32
public struct ATOMConsentInfo {
  public var dateCreated: Foundation.Date {
    get
  }
  public var dateUpdated: Foundation.Date {
    get
  }
  public var cmpId: Swift.Int {
    get
  }
  public var consentScreen: Swift.Int {
    get
  }
  public var consentLanguage: Swift.String {
    get
  }
  public var publisherCC: Swift.String {
    get
  }
  public var vendorListVersion: Swift.Int32 {
    get
  }
  public var tfcPolicyVersion: Swift.Int32 {
    get
  }
  public var isServiceSpecific: Swift.Bool {
    get
  }
  public var useNonStandardTexts: Swift.Bool {
    get
  }
  public var purposeOneTreatment: Swift.Int32 {
    get
  }
  public var purposeConsents: Swift.Set<ATOMPurposeIdentifier> {
    get
  }
  public func purposeConsent(forPurposeId purposeId: ATOMPurposeIdentifier) -> Swift.Bool
  public var purposeLegitimateInterests: Swift.Set<ATOMPurposeIdentifier> {
    get
  }
  public func purposeLegitimateInterest(forPurposeId purposeId: ATOMPurposeIdentifier) -> Swift.Bool
}
public enum ATOMConsentError : Swift.Error {
  case invalidBase64Encoding
  case parsingFailed
  case emptyData
  case invalidFormat
  case vendorIdOutOfRange
  case missingTCFConsentString
  case missingCCPAConsentString
  case noRegulationRequired
  public static func == (a: ATOMConsentError, b: ATOMConsentError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension ATOMConsentError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension Swift.String {
  public var base64Padded: Swift.String {
    get
  }
}
extension Foundation.Data {
  public func byte(forBit bit: Swift.Int64) -> Swift.Int?
  public func bytes(fromBit startBit: Swift.Int64, toBit endBit: Swift.Int64) -> [Swift.UInt8]
  public func data(fromBit startBit: Swift.Int64, toBit endBit: Swift.Int64) -> Foundation.Data
  public func intValue(fromBit startBit: Swift.Int64, toBit endBit: Swift.Int64) -> Swift.Int64
  public func intValue(for range: Foundation.NSRange) -> Swift.Int64
  public func data(for range: Foundation.NSRange) -> Foundation.Data
}
public protocol DatabaseWriter : DatabaseReader {
  func write<T>(_ updates: (Database) throws -> T) throws -> T
  func writeWithoutTransaction<T>(_ updates: (Database) throws -> T) rethrows -> T
  func barrierWriteWithoutTransaction<T>(_ updates: (Database) throws -> T) rethrows -> T
  func asyncWrite<T>(_ updates: @escaping (Database) throws -> T, completion: @escaping (Database, Swift.Result<T, any Swift.Error>) -> Swift.Void)
  func asyncWriteWithoutTransaction(_ updates: @escaping (Database) -> Swift.Void)
  func unsafeReentrantWrite<T>(_ updates: (Database) throws -> T) rethrows -> T
  func concurrentRead<T>(_ block: @escaping (Database) throws -> T) -> DatabaseFuture<T>
  func spawnConcurrentRead(_ block: @escaping (Swift.Result<Database, any Swift.Error>) -> Swift.Void)
}
extension DatabaseWriter {
  public func write<T>(_ updates: (Database) throws -> T) throws -> T
  public func asyncWrite<T>(_ updates: @escaping (Database) throws -> T, completion: @escaping (Database, Swift.Result<T, any Swift.Error>) -> Swift.Void)
  public func add(transactionObserver: any TransactionObserver, extent: Database.TransactionObservationExtent = .observerLifetime)
  public func remove(transactionObserver: any TransactionObserver)
  public func erase() throws
  public func vacuum() throws
}
@_hasMissingDesignatedInitializers public class DatabaseFuture<Value> {
  public func wait() throws -> Value
  @objc deinit
}
final public class AnyDatabaseWriter : DatabaseWriter {
  public init(_ base: any DatabaseWriter)
  final public var configuration: Configuration {
    get
  }
  final public func interrupt()
  final public func read<T>(_ block: (Database) throws -> T) throws -> T
  final public func asyncRead(_ block: @escaping (Swift.Result<Database, any Swift.Error>) -> Swift.Void)
  final public func unsafeRead<T>(_ block: (Database) throws -> T) throws -> T
  final public func unsafeReentrantRead<T>(_ block: (Database) throws -> T) throws -> T
  final public func concurrentRead<T>(_ block: @escaping (Database) throws -> T) -> DatabaseFuture<T>
  final public func spawnConcurrentRead(_ block: @escaping (Swift.Result<Database, any Swift.Error>) -> Swift.Void)
  final public func write<T>(_ updates: (Database) throws -> T) throws -> T
  final public func writeWithoutTransaction<T>(_ updates: (Database) throws -> T) rethrows -> T
  final public func barrierWriteWithoutTransaction<T>(_ updates: (Database) throws -> T) rethrows -> T
  final public func asyncWrite<T>(_ updates: @escaping (Database) throws -> T, completion: @escaping (Database, Swift.Result<T, any Swift.Error>) -> Swift.Void)
  final public func asyncWriteWithoutTransaction(_ updates: @escaping (Database) -> Swift.Void)
  final public func unsafeReentrantWrite<T>(_ updates: (Database) throws -> T) rethrows -> T
  @objc deinit
}
@available(iOS 8.0, *)
extension UIKit.UIWindow {
  @_Concurrency.MainActor @preconcurrency public func swizzle()
}
extension UIKit.UIWindow {
  @objc @_Concurrency.MainActor @preconcurrency dynamic public func swizzledSendEvent(_ event: UIKit.UIEvent)
}
public struct ATOMPinchTick : Swift.Equatable {
  public static func == (lhs: ATOMPinchTick, rhs: ATOMPinchTick) -> Swift.Bool
}
extension SQLExpression {
  @available(*, deprecated, message: "Use SQLLiteral initializer instead")
  public var sqlLiteral: SQLLiteral {
    get
  }
}
public struct SQLUnaryOperator : Swift.Hashable {
  public let sql: Swift.String
  public let needsRightSpace: Swift.Bool
  public init(_ sql: Swift.String, needsRightSpace: Swift.Bool)
  public static func == (a: SQLUnaryOperator, b: SQLUnaryOperator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct SQLExpressionUnary : SQLExpression {
  public let op: SQLUnaryOperator
  public let expression: any SQLExpression
  public init(_ op: SQLUnaryOperator, _ value: any SQLExpressible)
  public func expressionSQL(_ context: inout SQLGenerationContext, wrappedInParenthesis: Swift.Bool) -> Swift.String
  public func qualifiedExpression(with alias: TableAlias) -> any SQLExpression
}
public struct SQLBinaryOperator : Swift.Hashable {
  public let sql: Swift.String
  public let negatedSQL: Swift.String?
  public init(_ sql: Swift.String, negated: Swift.String? = nil)
  public var negated: SQLBinaryOperator? {
    get
  }
  public static func == (a: SQLBinaryOperator, b: SQLBinaryOperator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct SQLExpressionBinary : SQLExpression {
  public let lhs: any SQLExpression
  public let op: SQLBinaryOperator
  public let rhs: any SQLExpression
  public init(_ op: SQLBinaryOperator, _ lhs: any SQLExpressible, _ rhs: any SQLExpressible)
  public func expressionSQL(_ context: inout SQLGenerationContext, wrappedInParenthesis: Swift.Bool) -> Swift.String
  public var negated: any SQLExpression {
    get
  }
  public func qualifiedExpression(with alias: TableAlias) -> any SQLExpression
}
public struct SQLAssociativeBinaryOperator : Swift.Hashable {
  public let sql: Swift.String
  public let neutralValue: DatabaseValue
  public let strictlyAssociative: Swift.Bool
  public init(sql: Swift.String, neutralValue: DatabaseValue, strictlyAssociative: Swift.Bool)
  public static func == (a: SQLAssociativeBinaryOperator, b: SQLAssociativeBinaryOperator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Sequence where Self.Element == any SQLExpression {
  public func joined(operator: SQLAssociativeBinaryOperator) -> any SQLExpression
}
public struct SQLFunctionName : Swift.Hashable {
  public var sql: Swift.String
  public init(_ sql: Swift.String)
  public static func == (a: SQLFunctionName, b: SQLFunctionName) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct SQLExpressionFunction : SQLExpression {
  public let functionName: SQLFunctionName
  public let arguments: [any SQLExpression]
  public init(_ functionName: SQLFunctionName, arguments: [any SQLExpression])
  public init(_ functionName: SQLFunctionName, arguments: any SQLExpressible...)
  public func expressionSQL(_ context: inout SQLGenerationContext, wrappedInParenthesis: Swift.Bool) -> Swift.String
  public func qualifiedExpression(with alias: TableAlias) -> any SQLExpression
}
extension Swift.Array {
  @inlinable public init<C>(_ cursor: C) throws where Element == C.Element, C : Cursor {
        self.init()
        while let element = try cursor.next() {
            append(element)
        }
    }
}
extension Swift.Sequence {
  public func flatMap<SegmentOfResult>(_ transform: @escaping (Self.Iterator.Element) throws -> SegmentOfResult) -> FlattenCursor<MapCursor<AnyCursor<Self.Iterator.Element>, SegmentOfResult>> where SegmentOfResult : Cursor
}
extension Swift.Set {
  public init<C>(_ cursor: C) throws where Element == C.Element, C : Cursor
}
public protocol Cursor : AnyObject {
  associatedtype Element
  func next() throws -> Self.Element?
}
extension Cursor {
  public func isEmpty() throws -> Swift.Bool
  public func contains(where predicate: (Self.Element) throws -> Swift.Bool) throws -> Swift.Bool
  public func enumerated() -> EnumeratedCursor<Self>
  public func filter(_ isIncluded: @escaping (Self.Element) throws -> Swift.Bool) -> FilterCursor<Self>
  public func first(where predicate: (Self.Element) throws -> Swift.Bool) throws -> Self.Element?
  public func compactMap<ElementOfResult>(_ transform: @escaping (Self.Element) throws -> ElementOfResult?) -> MapCursor<FilterCursor<MapCursor<Self, ElementOfResult?>>, ElementOfResult>
  public func drop(while predicate: @escaping (Self.Element) throws -> Swift.Bool) -> DropWhileCursor<Self>
  public func dropFirst(_ n: Swift.Int) -> DropFirstCursor<Self>
  public func dropFirst() -> DropFirstCursor<Self>
  public func dropLast(_ n: Swift.Int) throws -> [Self.Element]
  public func dropLast() throws -> [Self.Element]
  public func flatMap<SegmentOfResult>(_ transform: @escaping (Self.Element) throws -> SegmentOfResult) -> FlattenCursor<MapCursor<Self, AnyCursor<SegmentOfResult.Element>>> where SegmentOfResult : Swift.Sequence
  public func flatMap<SegmentOfResult>(_ transform: @escaping (Self.Element) throws -> SegmentOfResult) -> FlattenCursor<MapCursor<Self, SegmentOfResult>> where SegmentOfResult : Cursor
  public func forEach(_ body: (Self.Element) throws -> Swift.Void) throws
  public func map<T>(_ transform: @escaping (Self.Element) throws -> T) -> MapCursor<Self, T>
  public func max(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) throws -> Self.Element?
  public func min(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) throws -> Self.Element?
  public func prefix(_ maxLength: Swift.Int) -> PrefixCursor<Self>
  public func prefix(while predicate: @escaping (Self.Element) throws -> Swift.Bool) -> PrefixWhileCursor<Self>
  public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Self.Element) throws -> Result) throws -> Result
  public func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: (inout Result, Self.Element) throws -> Swift.Void) throws -> Result
  public func suffix(_ maxLength: Swift.Int) throws -> [Self.Element]
}
extension Cursor where Self.Element : Swift.Equatable {
  public func contains(_ element: Self.Element) throws -> Swift.Bool
}
extension Cursor where Self.Element : Swift.Comparable {
  public func max() throws -> Self.Element?
  public func min() throws -> Self.Element?
}
extension Cursor where Self.Element : Cursor {
  public func joined() -> FlattenCursor<Self>
}
extension Cursor where Self.Element : Swift.Sequence {
  public func joined() -> FlattenCursor<MapCursor<Self, AnyCursor<Self.Element.Element>>>
}
extension Cursor where Self.Element : Swift.StringProtocol {
  public func joined(separator: Swift.String = "") throws -> Swift.String
}
final public class AnyCursor<Element> : Cursor {
  public init<C>(_ base: C) where Element == C.Element, C : Cursor
  convenience public init<I>(iterator: I) where Element == I.Element, I : Swift.IteratorProtocol
  convenience public init<S>(_ s: S) where Element == S.Element, S : Swift.Sequence
  public init(_ body: @escaping () throws -> Element?)
  final public func next() throws -> Element?
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DropFirstCursor<Base> : Cursor where Base : Cursor {
  final public func next() throws -> Base.Element?
  public typealias Element = Base.Element
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DropWhileCursor<Base> : Cursor where Base : Cursor {
  final public func next() throws -> Base.Element?
  public typealias Element = Base.Element
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class EnumeratedCursor<Base> : Cursor where Base : Cursor {
  final public func next() throws -> (Swift.Int, Base.Element)?
  public typealias Element = (Swift.Int, Base.Element)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class FilterCursor<Base> : Cursor where Base : Cursor {
  final public func next() throws -> Base.Element?
  public typealias Element = Base.Element
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class FlattenCursor<Base> : Cursor where Base : Cursor, Base.Element : Cursor {
  final public func next() throws -> Base.Element.Element?
  public typealias Element = Base.Element.Element
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class MapCursor<Base, Element> : Cursor where Base : Cursor {
  final public func next() throws -> Element?
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class PrefixCursor<Base> : Cursor where Base : Cursor {
  final public func next() throws -> Base.Element?
  public typealias Element = Base.Element
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class PrefixWhileCursor<Base> : Cursor where Base : Cursor {
  final public func next() throws -> Base.Element?
  public typealias Element = Base.Element
  @objc deinit
}
public struct PreparedRequest {
  public var statement: SelectStatement
  public var adapter: (any RowAdapter)?
  public init(statement: SelectStatement, adapter: (any RowAdapter)? = nil)
}
public protocol FetchRequest : DatabaseRegionConvertible {
  associatedtype RowDecoder
  func prepare(_ db: Database, forSingleResult singleResult: Swift.Bool) throws -> (SelectStatement, (any RowAdapter)?)
  func makePreparedRequest(_ db: Database, forSingleResult singleResult: Swift.Bool) throws -> PreparedRequest
  func fetchCount(_ db: Database) throws -> Swift.Int
}
extension FetchRequest {
  public func adapted(_ adapter: @escaping (Database) throws -> any RowAdapter) -> AdaptedFetchRequest<Self>
  public func fetchCount(_ db: Database) throws -> Swift.Int
  public func databaseRegion(_ db: Database) throws -> DatabaseRegion
  public func makePreparedRequest(_ db: Database, forSingleResult singleResult: Swift.Bool) throws -> PreparedRequest
  public func prepare(_ db: Database, forSingleResult singleResult: Swift.Bool) throws -> (SelectStatement, (any RowAdapter)?)
}
public struct AdaptedFetchRequest<Base> : FetchRequest where Base : FetchRequest {
  public typealias RowDecoder = Base.RowDecoder
  public func makePreparedRequest(_ db: Database, forSingleResult singleResult: Swift.Bool) throws -> PreparedRequest
  public func fetchCount(_ db: Database) throws -> Swift.Int
  public func databaseRegion(_ db: Database) throws -> DatabaseRegion
}
public struct AnyFetchRequest<T> : FetchRequest {
  public typealias RowDecoder = T
  public init<Request>(_ request: Request) where Request : FetchRequest
  @available(*, deprecated, message: "Define your own FetchRequest type instead.")
  public init(_ prepare: @escaping (Database, _ singleResult: Swift.Bool) throws -> (SelectStatement, (any RowAdapter)?))
  public func makePreparedRequest(_ db: Database, forSingleResult singleResult: Swift.Bool) throws -> PreparedRequest
  public func fetchCount(_ db: Database) throws -> Swift.Int
  public func databaseRegion(_ db: Database) throws -> DatabaseRegion
}
extension Database {
  @available(macOS 10.10, *)
  final public func create(table name: Swift.String, temporary: Swift.Bool = false, ifNotExists: Swift.Bool = false, withoutRowID: Swift.Bool, body: (TableDefinition) -> Swift.Void) throws
  final public func create(table name: Swift.String, temporary: Swift.Bool = false, ifNotExists: Swift.Bool = false, body: (TableDefinition) -> Swift.Void) throws
  final public func rename(table name: Swift.String, to newName: Swift.String) throws
  final public func alter(table name: Swift.String, body: (TableAlteration) -> Swift.Void) throws
  final public func drop(table name: Swift.String) throws
  final public func create(index name: Swift.String, on table: Swift.String, columns: [Swift.String], unique: Swift.Bool = false, ifNotExists: Swift.Bool = false) throws
  @available(macOS 10.10, *)
  final public func create(index name: Swift.String, on table: Swift.String, columns: [Swift.String], unique: Swift.Bool = false, ifNotExists: Swift.Bool = false, condition: any SQLExpressible) throws
  final public func drop(index name: Swift.String) throws
  final public func reindex(collation: Database.CollationName) throws
}
@_hasMissingDesignatedInitializers final public class TableDefinition {
  @discardableResult
  final public func autoIncrementedPrimaryKey(_ name: Swift.String, onConflict conflictResolution: Database.ConflictResolution? = nil) -> ColumnDefinition
  @discardableResult
  final public func column(_ name: Swift.String, _ type: Database.ColumnType? = nil) -> ColumnDefinition
  final public func primaryKey(_ columns: [Swift.String], onConflict conflictResolution: Database.ConflictResolution? = nil)
  final public func uniqueKey(_ columns: [Swift.String], onConflict conflictResolution: Database.ConflictResolution? = nil)
  final public func foreignKey(_ columns: [Swift.String], references table: Swift.String, columns destinationColumns: [Swift.String]? = nil, onDelete deleteAction: Database.ForeignKeyAction? = nil, onUpdate updateAction: Database.ForeignKeyAction? = nil, deferred: Swift.Bool = false)
  final public func check(_ condition: any SQLExpressible)
  final public func check(sql: Swift.String)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class TableAlteration {
  @discardableResult
  final public func add(column name: Swift.String, _ type: Database.ColumnType? = nil) -> ColumnDefinition
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  final public func rename(column name: Swift.String, to newName: Swift.String)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class ColumnDefinition {
  @discardableResult
  final public func primaryKey(onConflict conflictResolution: Database.ConflictResolution? = nil, autoincrement: Swift.Bool = false) -> Self
  @discardableResult
  final public func notNull(onConflict conflictResolution: Database.ConflictResolution? = nil) -> Self
  @discardableResult
  final public func unique(onConflict conflictResolution: Database.ConflictResolution? = nil) -> Self
  @discardableResult
  final public func indexed() -> Self
  @discardableResult
  final public func check(_ condition: (Column) -> any SQLExpressible) -> Self
  @discardableResult
  final public func check(sql: Swift.String) -> Self
  @discardableResult
  final public func defaults(to value: any DatabaseValueConvertible) -> Self
  @discardableResult
  final public func defaults(sql: Swift.String) -> Self
  @discardableResult
  final public func collate(_ collation: Database.CollationName) -> Self
  @discardableResult
  final public func references(_ table: Swift.String, column: Swift.String? = nil, onDelete deleteAction: Database.ForeignKeyAction? = nil, onUpdate updateAction: Database.ForeignKeyAction? = nil, deferred: Swift.Bool = false) -> Self
  @objc deinit
}
extension Database {
  final public func makeSelectStatement(sql: Swift.String) throws -> SelectStatement
  final public func cachedSelectStatement(sql: Swift.String) throws -> SelectStatement
  final public func makeUpdateStatement(sql: Swift.String) throws -> UpdateStatement
  final public func cachedUpdateStatement(sql: Swift.String) throws -> UpdateStatement
  final public func execute(sql: Swift.String, arguments: StatementArguments = StatementArguments()) throws
  final public func execute(literal sqlLiteral: SQLLiteral) throws
}
public class ATOMServiceContainer {
  public init()
  public func register<T>(_ type: T.Type, instance: T)
  public func register<T>(_ type: T.Type, factory: @escaping () -> T)
  public func resolve<T>(_ type: T.Type) -> T?
  public func clear()
  @objc deinit
}
extension ATOMServiceContainer {
  public static func createDefaultContainer() -> ATOMServiceContainer
}
public protocol ATOMSignalsDbManagerProtocol {
  func saveDeviceSignal(_ signalDBO: ATOMDeviceSignalDBO) throws
  func saveAccelerometerSignal(_ accelerometerDBO: ATOMAccelerometerSignalDBO) throws
  func saveGyroscopeSignal(_ gyroscopeDBO: ATOMGyroscopeSignalDBO) throws
  func flushAccelerometerSignalData() throws
}
public struct ATOMNetworkConstants {
  public static let configurationBaseURL: Swift.String
  public static let apiVersion: Swift.String
}
public protocol ATOMBatteryManagerProtocol : AnyObject {
  var isDeviceCharging: Swift.Bool { get }
  var batteryLevel: Swift.Int { get }
  var batterySaver: Swift.Bool { get }
}
public protocol DatabaseValueConvertible : SQLExpressible {
  var databaseValue: DatabaseValue { get }
  static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Self?
}
extension DatabaseValueConvertible {
  public var sqlExpression: any SQLExpression {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DatabaseValueCursor<Value> : Cursor where Value : DatabaseValueConvertible {
  @usableFromInline
  final internal let _statement: SelectStatement
  @usableFromInline
  final internal let _sqliteStatement: SQLiteStatement
  @usableFromInline
  final internal let _columnIndex: Swift.Int32
  @usableFromInline
  final internal var _done: Swift.Bool
  @objc deinit
  @inlinable final public func next() throws -> Value? {
        if _done {
             
             
            return nil
        }
        switch sqlite3_step(_sqliteStatement) {
        case SQLITE_DONE:
            _done = true
            return nil
        case SQLITE_ROW:
            return Value.decode(from: _sqliteStatement, atUncheckedIndex: _columnIndex)
        case let code:
            try _statement.didFail(withResultCode: code)
        }
    }
  public typealias Element = Value
}
@_hasMissingDesignatedInitializers final public class NullableDatabaseValueCursor<Value> : Cursor where Value : DatabaseValueConvertible {
  @usableFromInline
  final internal let _statement: SelectStatement
  @usableFromInline
  final internal let _sqliteStatement: SQLiteStatement
  @usableFromInline
  final internal let _columnIndex: Swift.Int32
  @usableFromInline
  final internal var _done: Swift.Bool
  @objc deinit
  @inlinable final public func next() throws -> Value?? {
        if _done {
             
             
            return nil
        }
        switch sqlite3_step(_sqliteStatement) {
        case SQLITE_DONE:
            _done = true
            return nil
        case SQLITE_ROW:
            return Value.decodeIfPresent(from: _sqliteStatement, atUncheckedIndex: _columnIndex)
        case let code:
            try _statement.didFail(withResultCode: code)
        }
    }
  public typealias Element = Value?
}
extension DatabaseValueConvertible {
  public static func fetchCursor(_ statement: SelectStatement, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> DatabaseValueCursor<Self>
  public static func fetchAll(_ statement: SelectStatement, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> [Self]
  public static func fetchOne(_ statement: SelectStatement, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> Self?
}
extension DatabaseValueConvertible {
  public static func fetchCursor(_ db: Database, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil) throws -> DatabaseValueCursor<Self>
  public static func fetchAll(_ db: Database, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil) throws -> [Self]
  public static func fetchOne(_ db: Database, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil) throws -> Self?
}
extension DatabaseValueConvertible {
  public static func fetchCursor<R>(_ db: Database, _ request: R) throws -> DatabaseValueCursor<Self> where R : FetchRequest
  public static func fetchAll<R>(_ db: Database, _ request: R) throws -> [Self] where R : FetchRequest
  public static func fetchOne<R>(_ db: Database, _ request: R) throws -> Self? where R : FetchRequest
}
extension FetchRequest where Self.RowDecoder : DatabaseValueConvertible {
  public func fetchCursor(_ db: Database) throws -> DatabaseValueCursor<Self.RowDecoder>
  public func fetchAll(_ db: Database) throws -> [Self.RowDecoder]
  public func fetchOne(_ db: Database) throws -> Self.RowDecoder?
}
extension Swift.Optional where Wrapped : DatabaseValueConvertible {
  public static func fetchCursor(_ statement: SelectStatement, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> NullableDatabaseValueCursor<Wrapped>
  public static func fetchAll(_ statement: SelectStatement, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> [Wrapped?]
}
extension Swift.Optional where Wrapped : DatabaseValueConvertible {
  public static func fetchCursor(_ db: Database, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil) throws -> NullableDatabaseValueCursor<Wrapped>
  public static func fetchAll(_ db: Database, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil) throws -> [Wrapped?]
}
extension Swift.Optional where Wrapped : DatabaseValueConvertible {
  public static func fetchCursor<R>(_ db: Database, _ request: R) throws -> NullableDatabaseValueCursor<Wrapped> where R : FetchRequest
  public static func fetchAll<R>(_ db: Database, _ request: R) throws -> [Wrapped?] where R : FetchRequest
}
extension FetchRequest where Self.RowDecoder : _OptionalProtocol, Self.RowDecoder._Wrapped : DatabaseValueConvertible {
  public func fetchCursor(_ db: Database) throws -> NullableDatabaseValueCursor<Self.RowDecoder._Wrapped>
  public func fetchAll(_ db: Database) throws -> [Self.RowDecoder._Wrapped?]
}
public typealias SQLiteStatement = Swift.OpaquePointer
@_hasMissingDesignatedInitializers public class Statement {
  final public let sqliteStatement: SQLiteStatement
  public var sql: Swift.String {
    get
  }
  @objc deinit
  public var arguments: StatementArguments {
    get
    set
  }
  public func validateArguments(_ arguments: StatementArguments) throws
  @available(*, deprecated, renamed: "validateArguments(_:)")
  public func validate(arguments: StatementArguments) throws
  public func setUncheckedArguments(_ arguments: StatementArguments)
  @available(*, deprecated, renamed: "setUncheckedArguments(_:)")
  public func unsafeSetArguments(_ arguments: StatementArguments)
  public func setArguments(_ arguments: StatementArguments) throws
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class SelectStatement : Statement {
  final public var databaseRegion: DatabaseRegion {
    get
  }
  final public var columnCount: Swift.Int {
    get
  }
  final public var columnNames: [Swift.String] {
    get
    set
  }
  final public func index(ofColumn name: Swift.String) -> Swift.Int?
  @usableFromInline
  final internal func didFail(withResultCode resultCode: Swift.Int32) throws -> Swift.Never
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class UpdateStatement : Statement {
  final public func execute(arguments: StatementArguments? = nil) throws
  @objc deinit
}
public struct StatementArguments : Swift.CustomStringConvertible, Swift.Equatable, Swift.ExpressibleByArrayLiteral, Swift.ExpressibleByDictionaryLiteral {
  public var isEmpty: Swift.Bool {
    get
  }
  public init()
  public init<Sequence>(_ sequence: Sequence) where Sequence : Swift.Sequence, Sequence.Element == (any DatabaseValueConvertible)?
  public init<Sequence>(_ sequence: Sequence) where Sequence : Swift.Sequence, Sequence.Element : DatabaseValueConvertible
  public init?(_ array: [Any])
  public init(_ dictionary: [Swift.String : (any DatabaseValueConvertible)?])
  public init<Sequence>(_ sequence: Sequence) where Sequence : Swift.Sequence, Sequence.Element == (Swift.String, (any DatabaseValueConvertible)?)
  public init?(_ dictionary: [Swift.AnyHashable : Any])
  public mutating func append(contentsOf arguments: StatementArguments) -> [Swift.String : DatabaseValue]
  public static func + (lhs: StatementArguments, rhs: StatementArguments) -> StatementArguments
  public static func &+ (lhs: StatementArguments, rhs: StatementArguments) -> StatementArguments
  public static func += (lhs: inout StatementArguments, rhs: StatementArguments)
  public static func == (a: StatementArguments, b: StatementArguments) -> Swift.Bool
  public typealias ArrayLiteralElement = (any DatabaseValueConvertible)?
  public typealias Key = Swift.String
  public typealias Value = (any DatabaseValueConvertible)?
}
extension StatementArguments {
  public init(arrayLiteral elements: (any DatabaseValueConvertible)?...)
}
extension StatementArguments {
  public init(dictionaryLiteral elements: (Swift.String, (any DatabaseValueConvertible)?)...)
}
extension StatementArguments {
  public var description: Swift.String {
    get
  }
}
public protocol AtomDelegate : AnyObject {
  func cohortsUpdated()
}
public protocol AtomGesturesDelegate : AnyObject {
  func gestureTracked(_ gesture: ATOMGesturesList)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class Atom : ObjectiveC.NSObject {
  weak public static var delegate: (any AtomDelegate)?
  weak public static var gestureDelegate: (any AtomGesturesDelegate)?
  public static var cohortsUpdatedCallback: ((Foundation.Date) -> Swift.Void)?
  public static var signalsSavedInLocalDatabaseCallback: ((Foundation.Date) -> Swift.Void)?
  @objc public static func start(withApiKey apiKey: Swift.String, isTest: Swift.Bool) throws
  public static func getCurrentNetworkConnection() -> ATOMReachability.Connection
  public static func refreshConsent() throws
  @objc public static func start(withApiKey apiKey: Swift.String, isTest: Swift.Bool, withCallback callback: ((Swift.Bool) -> ())?) throws
  @objc public static func setAtomLoggerLevels(_ logLevels: [Swift.String])
  @objc public static func start(isTest: Swift.Bool) throws
  @objc public static func start(isTest: Swift.Bool, withCallback callback: ((Swift.Bool) -> ())?) throws
  @objc public static func stop(withCallback callback: ((Swift.Bool) -> ())?)
  @available(*, deprecated, message: "Use cohorts(completion:) instead")
  @objc(getCohorts) public static func cohorts() -> [ATOMCohort]
  @objc(getCohortsWithCompletion:) public static func cohorts(completion: @escaping ([ATOMCohort]) -> Swift.Void)
  public static func updateCalculatedCohorts(onStartup isStartup: Swift.Bool = false, eventWasFired eventFired: Swift.Bool = false)
  public static func updateCalculatedVectors() throws
  @objc public static func vgParameterBase64String() -> Swift.String?
  @available(*, deprecated, message: "This method has been deprecated and no longer performs any operations")
  @objc(impressionFiredWithAdParameters:) public static func impressionFired(withAdParameters parameters: ATOMAdParameters)
  @objc public static func fire(eventWithName name: Swift.String, eventWithValue value: Any? = nil, withDelegate delegate: (any ATOMEventMatchDelegate)? = nil)
  @objc public static func fire(eventWithName name: Swift.String, eventWithValue value: Any? = nil, withDelegate delegate: (any ATOMEventMatchDelegate)? = nil, completion: @escaping (Swift.Bool, (any Swift.Error)?) -> Swift.Void)
  @objc deinit
}
extension Atom {
  public static func getGestures(withQuery q: Swift.String? = nil) throws -> [ATOMGestureObject]
  public static func getSwipeGestures(withQuery q: Swift.String? = nil) throws -> [ATOMSwipeDataPoint]
  public static func getPinchGestures(withQuery q: Swift.String? = nil) throws -> [ATOMPinchDataPoint]
  public static func getSwipeTicks(withQuery q: Swift.String? = nil) throws -> [ATOMSwipeTick]
  public static func getPinchTicks(withQuery q: Swift.String? = nil) throws -> [ATOMPinchTick]
}
extension Atom {
  public static func deleteAllGestures() throws
  public static func deletePrevious1000GesturesIfNeeded(completion: @escaping ((any Swift.Error)?) -> Swift.Void)
  public static func deleteAllSwipeGestures() throws
  public static func deleteAllPinchGestures() throws
  public static func deleteAllSwipeTicks() throws
  public static func deleteAllPinchTicks() throws
}
extension Atom : ATOMGesturesTrackerDelegate {
  public func gestureTracked(_ gesture: ATOMGesturesList)
}
extension Atom {
  public static var isGestureTrackingEnabled: Swift.Bool {
    get
  }
  public static var isTapGestureTrackingEnabled: Swift.Bool {
    get
  }
  public static var isSendHistoryOnStartupEnabled: Swift.Bool {
    get
  }
  public static var batteryLevel: Swift.Int {
    get
  }
  public static var batterySaver: Swift.Bool {
    get
  }
  public static var isDeviceCharging: Swift.Bool {
    get
  }
  public static var luminosityLevel: Swift.Int {
    get
  }
  public static var reachabilityLevel: Swift.String {
    get
  }
}
public struct SQLAssociation {
}
public struct SQLGenerationContext {
}
@_hasMissingDesignatedInitializers public class TableAlias : Swift.Hashable {
  public init(name: Swift.String? = nil)
  public subscript(selectable: any SQLSelectable) -> any SQLSelectable {
    get
  }
  public subscript(expression: any SQLExpression) -> any SQLExpression {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: TableAlias, rhs: TableAlias) -> Swift.Bool
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public struct DatabaseRegion : Swift.CustomStringConvertible, Swift.Equatable {
  public var isEmpty: Swift.Bool {
    get
  }
  public static let fullDatabase: DatabaseRegion
  public init()
  public init(table: Swift.String)
  public func union(_ other: DatabaseRegion) -> DatabaseRegion
  public mutating func formUnion(_ other: DatabaseRegion)
}
extension DatabaseRegion {
  public func isModified(byEventsOfKind eventKind: DatabaseEventKind) -> Swift.Bool
  public func isModified(by event: DatabaseEvent) -> Swift.Bool
}
extension DatabaseRegion {
  public static func == (lhs: DatabaseRegion, rhs: DatabaseRegion) -> Swift.Bool
}
extension DatabaseRegion {
  public var description: Swift.String {
    get
  }
}
public protocol DatabaseRegionConvertible {
  func databaseRegion(_ db: Database) throws -> DatabaseRegion
}
extension DatabaseRegion : DatabaseRegionConvertible {
  public func databaseRegion(_ db: Database) throws -> DatabaseRegion
}
public struct AnyDatabaseRegionConvertible : DatabaseRegionConvertible {
  public init(_ region: @escaping (Database) throws -> DatabaseRegion)
  public init(_ region: any DatabaseRegionConvertible)
  public func databaseRegion(_ db: Database) throws -> DatabaseRegion
}
extension TableRecord {
  public static func all() -> QueryInterfaceRequest<Self>
  public static func none() -> QueryInterfaceRequest<Self>
  public static func select(_ selection: any SQLSelectable...) -> QueryInterfaceRequest<Self>
  public static func select(_ selection: [any SQLSelectable]) -> QueryInterfaceRequest<Self>
  public static func select(sql: Swift.String, arguments: StatementArguments = StatementArguments()) -> QueryInterfaceRequest<Self>
  public static func select(literal sqlLiteral: SQLLiteral) -> QueryInterfaceRequest<Self>
  public static func select<RowDecoder>(_ selection: [any SQLSelectable], as type: RowDecoder.Type = RowDecoder.self) -> QueryInterfaceRequest<RowDecoder>
  public static func select<RowDecoder>(_ selection: any SQLSelectable..., as type: RowDecoder.Type = RowDecoder.self) -> QueryInterfaceRequest<RowDecoder>
  public static func select<RowDecoder>(sql: Swift.String, arguments: StatementArguments = StatementArguments(), as type: RowDecoder.Type = RowDecoder.self) -> QueryInterfaceRequest<RowDecoder>
  public static func select<RowDecoder>(literal sqlLiteral: SQLLiteral, as type: RowDecoder.Type = RowDecoder.self) -> QueryInterfaceRequest<RowDecoder>
  public static func annotated(with selection: [any SQLSelectable]) -> QueryInterfaceRequest<Self>
  public static func annotated(with selection: any SQLSelectable...) -> QueryInterfaceRequest<Self>
  public static func filter(_ predicate: any SQLExpressible) -> QueryInterfaceRequest<Self>
  public static func filter<PrimaryKeyType>(key: PrimaryKeyType?) -> QueryInterfaceRequest<Self> where PrimaryKeyType : DatabaseValueConvertible
  public static func filter<Sequence>(keys: Sequence) -> QueryInterfaceRequest<Self> where Sequence : Swift.Sequence, Sequence.Element : DatabaseValueConvertible
  public static func filter(key: [Swift.String : (any DatabaseValueConvertible)?]?) -> QueryInterfaceRequest<Self>
  public static func filter(keys: [[Swift.String : (any DatabaseValueConvertible)?]]) -> QueryInterfaceRequest<Self>
  public static func filter(sql: Swift.String, arguments: StatementArguments = StatementArguments()) -> QueryInterfaceRequest<Self>
  public static func filter(literal sqlLiteral: SQLLiteral) -> QueryInterfaceRequest<Self>
  public static func order(_ orderings: any SQLOrderingTerm...) -> QueryInterfaceRequest<Self>
  public static func order(_ orderings: [any SQLOrderingTerm]) -> QueryInterfaceRequest<Self>
  public static func orderByPrimaryKey() -> QueryInterfaceRequest<Self>
  public static func order(sql: Swift.String, arguments: StatementArguments = StatementArguments()) -> QueryInterfaceRequest<Self>
  public static func order(literal sqlLiteral: SQLLiteral) -> QueryInterfaceRequest<Self>
  public static func limit(_ limit: Swift.Int, offset: Swift.Int? = nil) -> QueryInterfaceRequest<Self>
  public static func aliased(_ alias: TableAlias) -> QueryInterfaceRequest<Self>
}
public protocol StatementColumnConvertible {
  init(sqliteStatement: SQLiteStatement, index: Swift.Int32)
}
@_hasMissingDesignatedInitializers final public class FastDatabaseValueCursor<Value> : Cursor where Value : DatabaseValueConvertible, Value : StatementColumnConvertible {
  @usableFromInline
  final internal let _statement: SelectStatement
  @usableFromInline
  final internal let _columnIndex: Swift.Int32
  @usableFromInline
  final internal let _sqliteStatement: SQLiteStatement
  @usableFromInline
  final internal var _done: Swift.Bool
  @objc deinit
  @inlinable final public func next() throws -> Value? {
        if _done {
             
             
            return nil
        }
        switch sqlite3_step(_sqliteStatement) {
        case SQLITE_DONE:
            _done = true
            return nil
        case SQLITE_ROW:
            return Value.fastDecode(from: _sqliteStatement, atUncheckedIndex: _columnIndex)
        case let code:
            try _statement.didFail(withResultCode: code)
        }
    }
  public typealias Element = Value
}
@_hasMissingDesignatedInitializers final public class FastNullableDatabaseValueCursor<Value> : Cursor where Value : DatabaseValueConvertible, Value : StatementColumnConvertible {
  @usableFromInline
  final internal let _statement: SelectStatement
  @usableFromInline
  final internal let _columnIndex: Swift.Int32
  @usableFromInline
  final internal let _sqliteStatement: SQLiteStatement
  @usableFromInline
  final internal var _done: Swift.Bool
  @objc deinit
  @inlinable final public func next() throws -> Value?? {
        if _done {
             
             
            return nil
        }
        switch sqlite3_step(_sqliteStatement) {
        case SQLITE_DONE:
            _done = true
            return nil
        case SQLITE_ROW:
            return Value.fastDecodeIfPresent(from: _sqliteStatement, atUncheckedIndex: _columnIndex)
        case let code:
            try _statement.didFail(withResultCode: code)
        }
    }
  public typealias Element = Value?
}
extension DatabaseValueConvertible where Self : StatementColumnConvertible {
  public static func fetchCursor(_ statement: SelectStatement, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> FastDatabaseValueCursor<Self>
  public static func fetchAll(_ statement: SelectStatement, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> [Self]
  public static func fetchOne(_ statement: SelectStatement, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> Self?
}
extension DatabaseValueConvertible where Self : StatementColumnConvertible {
  public static func fetchCursor(_ db: Database, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil) throws -> FastDatabaseValueCursor<Self>
  public static func fetchAll(_ db: Database, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil) throws -> [Self]
  public static func fetchOne(_ db: Database, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil) throws -> Self?
}
extension DatabaseValueConvertible where Self : StatementColumnConvertible {
  public static func fetchCursor<R>(_ db: Database, _ request: R) throws -> FastDatabaseValueCursor<Self> where R : FetchRequest
  public static func fetchAll<R>(_ db: Database, _ request: R) throws -> [Self] where R : FetchRequest
  public static func fetchOne<R>(_ db: Database, _ request: R) throws -> Self? where R : FetchRequest
}
extension FetchRequest where Self.RowDecoder : DatabaseValueConvertible, Self.RowDecoder : StatementColumnConvertible {
  public func fetchCursor(_ db: Database) throws -> FastDatabaseValueCursor<Self.RowDecoder>
  public func fetchAll(_ db: Database) throws -> [Self.RowDecoder]
  public func fetchOne(_ db: Database) throws -> Self.RowDecoder?
}
extension Swift.Optional where Wrapped : DatabaseValueConvertible, Wrapped : StatementColumnConvertible {
  public static func fetchCursor(_ statement: SelectStatement, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> FastNullableDatabaseValueCursor<Wrapped>
  public static func fetchAll(_ statement: SelectStatement, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> [Wrapped?]
}
extension Swift.Optional where Wrapped : DatabaseValueConvertible, Wrapped : StatementColumnConvertible {
  public static func fetchCursor(_ db: Database, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil) throws -> FastNullableDatabaseValueCursor<Wrapped>
  public static func fetchAll(_ db: Database, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil) throws -> [Wrapped?]
}
extension Swift.Optional where Wrapped : DatabaseValueConvertible, Wrapped : StatementColumnConvertible {
  public static func fetchCursor<R>(_ db: Database, _ request: R) throws -> FastNullableDatabaseValueCursor<Wrapped> where R : FetchRequest
  public static func fetchAll<R>(_ db: Database, _ request: R) throws -> [Wrapped?] where R : FetchRequest
}
extension FetchRequest where Self.RowDecoder : _OptionalProtocol, Self.RowDecoder._Wrapped : DatabaseValueConvertible, Self.RowDecoder._Wrapped : StatementColumnConvertible {
  public func fetchCursor(_ db: Database) throws -> FastNullableDatabaseValueCursor<Self.RowDecoder._Wrapped>
  public func fetchAll(_ db: Database) throws -> [Self.RowDecoder._Wrapped?]
}
final public class DatabasePool : DatabaseWriter {
  final public var path: Swift.String {
    get
  }
  final public var configuration: Configuration {
    get
  }
  public init(path: Swift.String, configuration: Configuration = Configuration()) throws
  @objc deinit
}
extension DatabasePool {
  final public func checkpoint(_ kind: Database.CheckpointMode = .passive) throws
}
extension DatabasePool {
  final public func releaseMemory()
  @available(*, deprecated, message: "Memory management is now enabled by default. This deprecated method does nothing.")
  final public func setupMemoryManagement(in application: UIKit.UIApplication)
}
extension DatabasePool : DatabaseReader {
  final public func interrupt()
  final public func read<T>(_ block: (Database) throws -> T) throws -> T
  final public func asyncRead(_ block: @escaping (Swift.Result<Database, any Swift.Error>) -> Swift.Void)
  final public func unsafeRead<T>(_ block: (Database) throws -> T) throws -> T
  final public func unsafeReentrantRead<T>(_ block: (Database) throws -> T) throws -> T
  final public func concurrentRead<T>(_ block: @escaping (Database) throws -> T) -> DatabaseFuture<T>
  final public func spawnConcurrentRead(_ block: @escaping (Swift.Result<Database, any Swift.Error>) -> Swift.Void)
  final public func asyncConcurrentRead(_ block: @escaping (Swift.Result<Database, any Swift.Error>) -> Swift.Void)
  final public func invalidateReadOnlyConnections()
  final public func writeWithoutTransaction<T>(_ updates: (Database) throws -> T) rethrows -> T
  final public func barrierWriteWithoutTransaction<T>(_ updates: (Database) throws -> T) rethrows -> T
  final public func writeInTransaction(_ kind: Database.TransactionKind? = nil, _ updates: (Database) throws -> Database.TransactionCompletion) throws
  final public func unsafeReentrantWrite<T>(_ updates: (Database) throws -> T) rethrows -> T
  final public func asyncWriteWithoutTransaction(_ updates: @escaping (Database) -> Swift.Void)
}
extension DatabasePool {
  final public func makeSnapshot() throws -> DatabaseSnapshot
}
extension FetchableRecord where Self : TableRecord {
  public static func fetchCursor(_ db: Database) throws -> RecordCursor<Self>
  public static func fetchAll(_ db: Database) throws -> [Self]
  public static func fetchOne(_ db: Database) throws -> Self?
}
extension FetchableRecord where Self : TableRecord {
  public static func fetchCursor<Sequence>(_ db: Database, keys: Sequence) throws -> RecordCursor<Self> where Sequence : Swift.Sequence, Sequence.Element : DatabaseValueConvertible
  public static func fetchAll<Sequence>(_ db: Database, keys: Sequence) throws -> [Self] where Sequence : Swift.Sequence, Sequence.Element : DatabaseValueConvertible
  public static func fetchOne<PrimaryKeyType>(_ db: Database, key: PrimaryKeyType?) throws -> Self? where PrimaryKeyType : DatabaseValueConvertible
}
extension FetchableRecord where Self : TableRecord {
  public static func fetchCursor(_ db: Database, keys: [[Swift.String : (any DatabaseValueConvertible)?]]) throws -> RecordCursor<Self>
  public static func fetchAll(_ db: Database, keys: [[Swift.String : (any DatabaseValueConvertible)?]]) throws -> [Self]
  public static func fetchOne(_ db: Database, key: [Swift.String : (any DatabaseValueConvertible)?]?) throws -> Self?
}
public protocol SelectionRequest {
  func select(_ selection: [any SQLSelectable]) -> Self
  func annotated(with selection: [any SQLSelectable]) -> Self
}
extension SelectionRequest {
  public func select(_ selection: any SQLSelectable...) -> Self
  public func select(sql: Swift.String, arguments: StatementArguments = StatementArguments()) -> Self
  public func select(literal sqlLiteral: SQLLiteral) -> Self
  public func annotated(with selection: any SQLSelectable...) -> Self
}
public protocol FilteredRequest {
  func filter(_ predicate: @escaping (Database) throws -> any SQLExpressible) -> Self
  func expectingSingleResult() -> Self
}
extension FilteredRequest {
  public func expectingSingleResult() -> Self
  public func filter(_ predicate: any SQLExpressible) -> Self
  public func filter(sql: Swift.String, arguments: StatementArguments = StatementArguments()) -> Self
  public func filter(literal sqlLiteral: SQLLiteral) -> Self
  public func none() -> Self
}
public protocol TableRequest {
  var databaseTableName: Swift.String { get }
  func aliased(_ alias: TableAlias) -> Self
}
extension TableRequest where Self : FilteredRequest {
  public func filter<PrimaryKeyType>(key: PrimaryKeyType?) -> Self where PrimaryKeyType : DatabaseValueConvertible
  public func filter<Sequence>(keys: Sequence) -> Self where Sequence : Swift.Sequence, Sequence.Element : DatabaseValueConvertible
  public func filter(key: [Swift.String : (any DatabaseValueConvertible)?]?) -> Self
  public func filter(keys: [[Swift.String : (any DatabaseValueConvertible)?]]) -> Self
}
extension TableRequest where Self : OrderedRequest {
  public func orderByPrimaryKey() -> Self
}
extension TableRequest where Self : AggregatingRequest {
  public func groupByPrimaryKey() -> Self
}
public protocol AggregatingRequest {
  func group(_ expressions: @escaping (Database) throws -> [any SQLExpressible]) -> Self
  func having(_ predicate: any SQLExpressible) -> Self
}
extension AggregatingRequest {
  public func group(_ expressions: [any SQLExpressible]) -> Self
  public func group(_ expressions: any SQLExpressible...) -> Self
  public func group(sql: Swift.String, arguments: StatementArguments = StatementArguments()) -> Self
  public func group(literal sqlLiteral: SQLLiteral) -> Self
  public func having(sql: Swift.String, arguments: StatementArguments = StatementArguments()) -> Self
  public func having(literal sqlLiteral: SQLLiteral) -> Self
}
public protocol OrderedRequest {
  func order(_ orderings: @escaping (Database) throws -> [any SQLOrderingTerm]) -> Self
  func reversed() -> Self
  func unordered() -> Self
}
extension OrderedRequest {
  public func order(_ orderings: any SQLOrderingTerm...) -> Self
  public func order(_ orderings: [any SQLOrderingTerm]) -> Self
  public func order(sql: Swift.String, arguments: StatementArguments = StatementArguments()) -> Self
  public func order(literal sqlLiteral: SQLLiteral) -> Self
}
public protocol _JoinableRequest {
  func _including(all association: SQLAssociation) -> Self
  func _including(optional association: SQLAssociation) -> Self
  func _including(required association: SQLAssociation) -> Self
  func _joining(optional association: SQLAssociation) -> Self
  func _joining(required association: SQLAssociation) -> Self
}
public protocol JoinableRequest : _JoinableRequest {
  associatedtype RowDecoder : TableRecord
}
public protocol DerivableRequest : FilteredRequest, JoinableRequest, OrderedRequest, SelectionRequest, TableRequest {
}
public protocol ATOMLoggerDelegate : AnyObject {
  func didReceiveLog(className: Swift.String, methodName: Swift.String, message: Swift.String)
}
@objc @_inheritsConvenienceInitializers public class ATOMLogger : ObjectiveC.NSObject {
  weak public static var delegate: (any ATOMLoggerDelegate)?
  public static func setLogLevels(_ logLevels: [Swift.String])
  public static func errorLog(fromClass className: Swift.String, fromMethod: Swift.String, withMessage: Swift.String)
  public static func debugLog(fromClass className: Swift.String, fromMethod: Swift.String, withMessage: Swift.String)
  public static func gestureLog(fromClass className: Swift.String, fromMethod: Swift.String, withMessage: Swift.String)
  public static func signalLog(fromClass className: Swift.String, fromMethod: Swift.String, withMessage: Swift.String)
  public static func mlLog(fromClass className: Swift.String, fromMethod: Swift.String, withMessage: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
public class ATOMSynchronizedDictionary<Key, Value> where Key : Swift.Hashable {
  public init()
  public func set(value: Value, forKey key: Key)
  public func removeValue(forKey key: Key)
  public func removeAll()
  public func setSync(value: Value, forKey key: Key)
  public func removeValueSync(forKey key: Key) -> Value?
  public func removeAllSync()
  public func value(forKey key: Key) -> Value?
  public var count: Swift.Int {
    get
  }
  public var keys: [Key] {
    get
  }
  public var values: [Value] {
    get
  }
  public subscript(key: Key) -> Value? {
    get
    set
  }
  public func findKey(where predicate: (Key, Value) throws -> Swift.Bool) rethrows -> Key?
  public func snapshot() -> [Key : Value]
  @objc deinit
}
extension ATOMSynchronizedDictionary : Swift.Sequence {
  public func makeIterator() -> Swift.DictionaryIterator<Key, Value>
  public typealias Element = Swift.Dictionary<Key, Value>.Iterator.Element
  public typealias Iterator = Swift.DictionaryIterator<Key, Value>
}
@_hasMissingDesignatedInitializers final public class ATOMDBSignalQueries {
  @objc deinit
}
public protocol VirtualTableModule {
  associatedtype TableDefinition
  var moduleName: Swift.String { get }
  func makeTableDefinition() -> Self.TableDefinition
  func moduleArguments(for definition: Self.TableDefinition, in db: Database) throws -> [Swift.String]
  func database(_ db: Database, didCreate tableName: Swift.String, using definition: Self.TableDefinition) throws
}
extension Database {
  final public func create(virtualTable name: Swift.String, ifNotExists: Swift.Bool = false, using module: Swift.String) throws
  final public func create<Module>(virtualTable tableName: Swift.String, ifNotExists: Swift.Bool = false, using module: Module, _ body: ((Module.TableDefinition) -> Swift.Void)? = nil) throws where Module : VirtualTableModule
}
public class ATOMSignalsProviderImpl : ATOMSignalsProviderProtocol {
  public var batteryManager: any ATOMBatteryManagerProtocol {
    get
  }
  public var reachabilityManager: any ATOMReachabilityManagerProtocol {
    get
  }
  public var luminosityManager: any ATOMLuminosityManagerProtocol {
    get
  }
  public var signalTrackManager: any ATOMSignalTrackManagerProtocol {
    get
  }
  public var deviceTrackManager: any ATOMDeviceTrackManagerProtocol {
    get
  }
  public var signalsDbManager: any ATOMSignalsDbManagerProtocol {
    get
  }
  public init()
  @objc deinit
}
public struct ATOMAccelerometerSignalDBO {
}
public struct SQLCollatedExpression {
  public let expression: any SQLExpression
  public let collationName: Database.CollationName
  public var asc: any SQLOrderingTerm {
    get
  }
  public var desc: any SQLOrderingTerm {
    get
  }
}
extension SQLCollatedExpression : SQLOrderingTerm {
  public var reversed: any SQLOrderingTerm {
    get
  }
  public func orderingTermSQL(_ context: inout SQLGenerationContext) -> Swift.String
  public func qualifiedOrdering(with alias: TableAlias) -> any SQLOrderingTerm
}
@objc public protocol ATOMEventMatchDelegate {
  @objc func matchedEvent(withName name: Swift.String, withValue value: Any?)
}
@_inheritsConvenienceInitializers @objc final public class ATOMEventAPI : ObjectiveC.NSObject {
  weak public static var delegate: (any ATOMEventMatchDelegate)?
  @objc public static func fire(event: ATOMEvent, withDelegate delegate: (any ATOMEventMatchDelegate)? = nil, completion: @escaping (Swift.Bool, (any Swift.Error)?) -> Swift.Void)
  @objc override dynamic public init()
  @objc deinit
}
extension DatabaseValueConvertible where Self : Swift.Encodable {
  public var databaseValue: DatabaseValue {
    get
  }
}
extension DatabaseValueConvertible where Self : Swift.Encodable, Self : Swift.RawRepresentable, Self.RawValue : DatabaseValueConvertible {
  public var databaseValue: DatabaseValue {
    get
  }
}
public struct ATOMTouchConfiguration {
  public var color: UIKit.UIColor?
  public var image: UIKit.UIImage?
  public var defaultSize: CoreFoundation.CGSize
  public var showsTimer: Swift.Bool
  public var showsTouchRadius: Swift.Bool
  public var showsLog: Swift.Bool
  public init()
}
public struct ATOMDeviceSignalDBO {
}
public protocol ATOMLuminosityManagerProtocol : AnyObject {
  var getScreenBrightness: Swift.Int { get }
}
@_hasMissingDesignatedInitializers final public class ATOMLuminosityManagerImpl : ATOMLuminosityManagerProtocol {
  final public var getScreenBrightness: Swift.Int {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DatabaseSnapshot : DatabaseReader {
  public var configuration: Configuration {
    get
  }
  @objc deinit
}
extension DatabaseSnapshot {
  public func interrupt()
  public func read<T>(_ block: (Database) throws -> T) rethrows -> T
  public func asyncRead(_ block: @escaping (Swift.Result<Database, any Swift.Error>) -> Swift.Void)
  public func unsafeRead<T>(_ block: (Database) throws -> T) rethrows -> T
  public func unsafeReentrantRead<T>(_ block: (Database) throws -> T) throws -> T
}
public protocol EncodableRecord {
  func encode(to container: inout PersistenceContainer)
  static var databaseEncodingUserInfo: [Swift.CodingUserInfoKey : Any] { get }
  static func databaseJSONEncoder(for column: Swift.String) -> Foundation.JSONEncoder
  static var databaseDateEncodingStrategy: DatabaseDateEncodingStrategy { get }
  static var databaseUUIDEncodingStrategy: DatabaseUUIDEncodingStrategy { get }
}
extension EncodableRecord {
  public static var databaseEncodingUserInfo: [Swift.CodingUserInfoKey : Any] {
    get
  }
  public static func databaseJSONEncoder(for column: Swift.String) -> Foundation.JSONEncoder
  public static var databaseDateEncodingStrategy: DatabaseDateEncodingStrategy {
    get
  }
  public static var databaseUUIDEncodingStrategy: DatabaseUUIDEncodingStrategy {
    get
  }
}
extension EncodableRecord {
  public var databaseDictionary: [Swift.String : DatabaseValue] {
    get
  }
}
extension EncodableRecord {
  public func databaseEquals(_ record: Self) -> Swift.Bool
  public func databaseChanges<Record>(from record: Record) -> [Swift.String : DatabaseValue] where Record : EncodableRecord
}
public struct PersistenceContainer {
  @usableFromInline
  internal var storage: OrderedDictionary<Swift.String, (any DatabaseValueConvertible)?>
  @inlinable public subscript(column: Swift.String) -> (any DatabaseValueConvertible)? {
    get { return storage[column] ?? nil }
    set { storage.updateValue(newValue, forKey: column) }
  }
  @inlinable public subscript<Column>(column: Column) -> (any DatabaseValueConvertible)? where Column : ColumnExpression {
    get { return self[column.name] }
    set { self[column.name] = newValue }
  }
}
public enum DatabaseDateEncodingStrategy {
  case deferredToDate
  case timeIntervalSinceReferenceDate
  case timeIntervalSince1970
  case secondsSince1970
  case millisecondsSince1970
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  case iso8601
  case formatted(Foundation.DateFormatter)
  case custom((Foundation.Date) -> (any DatabaseValueConvertible)?)
}
public enum DatabaseUUIDEncodingStrategy {
  case deferredToUUID
  case string
  public static func == (a: DatabaseUUIDEncodingStrategy, b: DatabaseUUIDEncodingStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class DatabaseQueue : DatabaseWriter {
  final public var configuration: Configuration {
    get
  }
  final public var path: Swift.String {
    get
  }
  public init(path: Swift.String, configuration: Configuration = Configuration()) throws
  public init(configuration: Configuration = Configuration())
  @objc deinit
}
extension DatabaseQueue {
  final public func releaseMemory()
  @available(*, deprecated, message: "Memory management is now enabled by default. This deprecated method does nothing.")
  final public func setupMemoryManagement(in application: UIKit.UIApplication)
}
extension DatabaseQueue {
  final public func interrupt()
  final public func read<T>(_ block: (Database) throws -> T) rethrows -> T
  final public func asyncRead(_ block: @escaping (Swift.Result<Database, any Swift.Error>) -> Swift.Void)
  final public func unsafeRead<T>(_ block: (Database) throws -> T) rethrows -> T
  final public func unsafeReentrantRead<T>(_ block: (Database) throws -> T) rethrows -> T
  final public func concurrentRead<T>(_ block: @escaping (Database) throws -> T) -> DatabaseFuture<T>
  final public func spawnConcurrentRead(_ block: @escaping (Swift.Result<Database, any Swift.Error>) -> Swift.Void)
  final public func inTransaction(_ kind: Database.TransactionKind? = nil, _ updates: (Database) throws -> Database.TransactionCompletion) throws
  final public func writeWithoutTransaction<T>(_ updates: (Database) throws -> T) rethrows -> T
  final public func barrierWriteWithoutTransaction<T>(_ updates: (Database) throws -> T) rethrows -> T
  final public func inDatabase<T>(_ updates: (Database) throws -> T) rethrows -> T
  final public func unsafeReentrantWrite<T>(_ updates: (Database) throws -> T) rethrows -> T
  final public func asyncWriteWithoutTransaction(_ updates: @escaping (Database) -> Swift.Void)
}
public protocol ColumnExpression : SQLExpression {
  var name: Swift.String { get }
}
extension ColumnExpression {
  public func expressionSQL(_ context: inout SQLGenerationContext, wrappedInParenthesis: Swift.Bool) -> Swift.String
  public func qualifiedExpression(with alias: TableAlias) -> any SQLExpression
}
public struct Column : ColumnExpression {
  public static let rowID: Column
  public var name: Swift.String
  public init(_ name: Swift.String)
  public init(_ codingKey: any Swift.CodingKey)
}
extension ColumnExpression where Self : Swift.RawRepresentable, Self.RawValue == Swift.String {
  public var name: Swift.String {
    get
  }
}
open class Record : FetchableRecord, TableRecord, PersistableRecord {
  public init()
  required public init(row: Row)
  open class var databaseTableName: Swift.String {
    get
  }
  open class var persistenceConflictPolicy: PersistenceConflictPolicy {
    get
  }
  open class var databaseSelection: [any SQLSelectable] {
    get
  }
  open func encode(to container: inout PersistenceContainer)
  open func didInsert(with rowID: Swift.Int64, for column: Swift.String?)
  open func copy() -> Self
  public var hasDatabaseChanges: Swift.Bool {
    get
    set
  }
  public var databaseChanges: [Swift.String : DatabaseValue?] {
    get
  }
  open func insert(_ db: Database) throws
  open func update(_ db: Database, columns: Swift.Set<Swift.String>) throws
  @discardableResult
  final public func updateChanges(_ db: Database) throws -> Swift.Bool
  final public func save(_ db: Database) throws
  @discardableResult
  open func delete(_ db: Database) throws -> Swift.Bool
  @objc deinit
}
public struct DatabaseValue : Swift.Hashable, Swift.CustomStringConvertible, DatabaseValueConvertible, SQLExpression {
  public let storage: DatabaseValue.Storage
  public static let null: DatabaseValue
  public enum Storage : Swift.Equatable {
    case null
    case int64(Swift.Int64)
    case double(Swift.Double)
    case string(Swift.String)
    case blob(Foundation.Data)
    public var value: (any DatabaseValueConvertible)? {
      get
    }
    public static func == (lhs: DatabaseValue.Storage, rhs: DatabaseValue.Storage) -> Swift.Bool
  }
  public init?(value: Any)
  public var isNull: Swift.Bool {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension DatabaseValue {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: DatabaseValue, rhs: DatabaseValue) -> Swift.Bool
}
extension DatabaseValue {
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> DatabaseValue?
}
extension DatabaseValue {
  public var sqlExpression: any SQLExpression {
    get
  }
}
extension DatabaseValue {
  public func expressionSQL(_ context: inout SQLGenerationContext, wrappedInParenthesis: Swift.Bool) -> Swift.String
  public var negated: any SQLExpression {
    get
  }
  public func qualifiedExpression(with alias: TableAlias) -> any SQLExpression
}
extension DatabaseValue {
  public var description: Swift.String {
    get
  }
}
public enum ATOMGesturesList : Swift.String, Swift.CaseIterable {
  case swipeUp
  case swipeDown
  case swipeLeft
  case swipeRight
  case pinchIn
  case pinchOut
  case tap
  public init?(rawValue: Swift.String)
  public typealias AllCases = [ATOMGesturesList]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [ATOMGesturesList] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public protocol ATOMGesturesTrackerDelegate : AnyObject {
  func gestureTracked(_ gesture: ATOMGesturesList)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class AtomGestures : ObjectiveC.NSObject {
  weak public static var delegate: (any ATOMGesturesTrackerDelegate)?
  public static func start()
  public static func stop()
  @objc deinit
}
extension AtomGestures {
  public static func getGestures(withQuery q: Swift.String? = nil) throws -> [ATOMGestureObject]
  public static func getSwipeGestures(withQuery q: Swift.String? = nil) throws -> [ATOMSwipeDataPoint]
  public static func getPinchGestures(withQuery q: Swift.String? = nil) throws -> [ATOMPinchDataPoint]
  public static func getSwipeTicks(withQuery q: Swift.String? = nil) throws -> [ATOMSwipeTick]
  public static func getPinchTicks(withQuery q: Swift.String? = nil) throws -> [ATOMPinchTick]
  public static func getTapGestures(withQuery q: Swift.String? = nil) throws -> [ATOMTapDataPoint]
}
extension AtomGestures {
  public static func deleteAllGestures() throws
  public static func deletePrevious1000Gestures(completion: @escaping ((any Swift.Error)?) -> Swift.Void)
  public static func deleteAllSwipeGestures() throws
  public static func deleteAllPinchGestures() throws
  public static func deleteAllSwipeTicks() throws
  public static func deleteAllPinchTicks() throws
  public static func deleteAllTapGestures() throws
}
public enum ATOMConfigurationError : Swift.Error, Swift.Equatable {
  case networkError
  case parsingError
  case invalidResponse
  case configurationNotFound
  public static func == (a: ATOMConfigurationError, b: ATOMConfigurationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ATOMConfigurationNetworkProviderProtocol {
  func fetchConfiguration(from url: Foundation.URL, completion: @escaping (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  func buildConfigurationURL(apiKey: Swift.String, date: Swift.Int, ssid: Swift.String) -> Foundation.URL?
}
public enum ATOMNetworkError : Swift.Error {
  case invalidURL
  case invalidResponse
  case httpError(statusCode: Swift.Int)
  case decodingError(any Swift.Error)
  case networkError(any Swift.Error)
  case noData
}
public struct ATOMRequest {
  public let url: Foundation.URL
  public let method: HTTPMethod
  public let headers: [Swift.String : Swift.String]
  public let body: Foundation.Data?
  public let timeout: Foundation.TimeInterval
  public init(url: Foundation.URL, method: HTTPMethod = .GET, headers: [Swift.String : Swift.String] = [:], body: Foundation.Data? = nil, timeout: Foundation.TimeInterval = 30)
}
public struct ATOMResponse {
  public let data: Foundation.Data?
  public let statusCode: Swift.Int
  public let headers: [Swift.String : Swift.String]
  public init(data: Foundation.Data?, statusCode: Swift.Int, headers: [Swift.String : Swift.String])
}
public enum HTTPMethod : Swift.String {
  case GET
  case POST
  case PUT
  case DELETE
  case PATCH
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol ATOMNetworkClient : AnyObject {
  func request(_ request: ATOMRequest, completion: @escaping (Swift.Result<ATOMResponse, ATOMNetworkError>) -> Swift.Void)
  func request<T>(_ request: ATOMRequest, responseType: T.Type, completion: @escaping (Swift.Result<T, ATOMNetworkError>) -> Swift.Void) where T : Swift.Decodable, T : Swift.Encodable
}
public protocol ATOMReachabilityProvider {
  var isConnected: Swift.Bool { get }
  func startMonitoring()
  func stopMonitoring()
}
public class ATOMNetworkReachabilityWrapper : ATOMReachabilityProvider {
  public var isConnected: Swift.Bool {
    get
  }
  public init()
  public func startMonitoring()
  public func stopMonitoring()
  @objc deinit
}
public class ATOMURLSessionClient : ATOMNetworkClient {
  public init(session: Foundation.URLSession = URLSession.shared, queue: Dispatch.DispatchQueue = DispatchQueue(label: "atom.network"))
  public func request(_ request: ATOMRequest, completion: @escaping (Swift.Result<ATOMResponse, ATOMNetworkError>) -> Swift.Void)
  public func request<T>(_ request: ATOMRequest, responseType: T.Type, completion: @escaping (Swift.Result<T, ATOMNetworkError>) -> Swift.Void) where T : Swift.Decodable, T : Swift.Encodable
  @objc deinit
}
public class ATOMNetwork {
  public init(client: any ATOMNetworkClient = ATOMURLSessionClient(), reachability: any ATOMReachabilityProvider = ATOMNetworkReachabilityWrapper())
  public var networkClient: any ATOMNetworkClient {
    get
  }
  public var isNetworkAvailable: Swift.Bool {
    get
  }
  public func startReachabilityMonitoring()
  public func stopReachabilityMonitoring()
  @objc deinit
}
public class ATOMConfigurationNetworkProvider : ATOMConfigurationNetworkProviderProtocol {
  public init(networkClient: any ATOMNetworkClient, baseURL: Swift.String, apiVersion: Swift.String, userDefaults: Foundation.UserDefaults = .standard)
  public func fetchConfiguration(from url: Foundation.URL, completion: @escaping (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  public func buildConfigurationURL(apiKey: Swift.String, date: Swift.Int = 0, ssid: Swift.String) -> Foundation.URL?
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers public class ATOMCohort : ObjectiveC.NSObject, Swift.Codable {
  public var id: Swift.Int {
    get
  }
  public var name: Swift.String {
    get
  }
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
extension ATOMCohort {
  public static func == (lhs: ATOMCohort, rhs: ATOMCohort) -> Swift.Bool
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override dynamic public var hash: Swift.Int {
    @objc get
  }
}
@objc final public class ATOMFlush : ObjectiveC.NSObject, Swift.Codable {
  final public var name: Swift.String {
    get
  }
  final public var query: Swift.String {
    get
  }
  final public var initialCleanupInSeconds: Swift.Int {
    get
  }
  final public var cyclicCleanupInSeconds: Swift.Int {
    get
  }
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public func splittingRowAdapters(columnCounts: [Swift.Int]) -> [any RowAdapter]
public struct LayoutedColumnMapping {
  public let layoutColumns: [(Swift.Int, Swift.String)]
  public init<S>(layoutColumns: S) where S : Swift.Sequence, S.Element == (Swift.Int, Swift.String)
}
extension LayoutedColumnMapping : LayoutedRowAdapter {
  public var mapping: LayoutedColumnMapping {
    get
  }
  public var scopes: [Swift.String : any LayoutedRowAdapter] {
    get
  }
}
extension LayoutedColumnMapping : RowLayout {
  public func layoutIndex(ofColumn name: Swift.String) -> Swift.Int?
}
public protocol LayoutedRowAdapter {
  var mapping: LayoutedColumnMapping { get }
  var scopes: [Swift.String : any LayoutedRowAdapter] { get }
}
public protocol RowLayout {
  var layoutColumns: [(Swift.Int, Swift.String)] { get }
  func layoutIndex(ofColumn name: Swift.String) -> Swift.Int?
}
extension SelectStatement : RowLayout {
  final public var layoutColumns: [(Swift.Int, Swift.String)] {
    get
  }
  final public func layoutIndex(ofColumn name: Swift.String) -> Swift.Int?
}
public protocol RowAdapter {
  func layoutedAdapter(from layout: any RowLayout) throws -> any LayoutedRowAdapter
}
extension RowAdapter {
  public func addingScopes(_ scopes: [Swift.String : any RowAdapter]) -> any RowAdapter
}
public struct EmptyRowAdapter : RowAdapter {
  public init()
  public func layoutedAdapter(from layout: any RowLayout) throws -> any LayoutedRowAdapter
}
public struct ColumnMapping : RowAdapter {
  public init(_ mapping: [Swift.String : Swift.String])
  public func layoutedAdapter(from layout: any RowLayout) throws -> any LayoutedRowAdapter
}
public struct SuffixRowAdapter : RowAdapter {
  public init(fromIndex index: Swift.Int)
  public func layoutedAdapter(from layout: any RowLayout) throws -> any LayoutedRowAdapter
}
public struct RangeRowAdapter : RowAdapter {
  public init(_ range: Swift.CountableRange<Swift.Int>)
  public init(_ range: Swift.CountableClosedRange<Swift.Int>)
  public func layoutedAdapter(from layout: any RowLayout) throws -> any LayoutedRowAdapter
}
public struct ScopeAdapter : RowAdapter {
  public init(_ scopes: [Swift.String : any RowAdapter])
  public init(base: any RowAdapter, scopes: [Swift.String : any RowAdapter])
  public func layoutedAdapter(from layout: any RowLayout) throws -> any LayoutedRowAdapter
}
@_inheritsConvenienceInitializers @objc public class ATOMLogLevels : ObjectiveC.NSObject {
  @objc public static let none: Swift.String
  @objc public static let error: Swift.String
  @objc public static let debug: Swift.String
  @objc public static let gesture: Swift.String
  @objc public static let signal: Swift.String
  @objc public static let ml: Swift.String
  @objc override dynamic public init()
  @objc deinit
}
public protocol ATOMSignalTrackManagerProtocol {
  func start()
  func stop()
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ATOMVisualizer : ObjectiveC.NSObject {
  public static let sharedInstance: ATOMVisualizer
  @objc deinit
  final public func removeAllTouchViews()
}
extension ATOMVisualizer {
  final public class func isEnabled() -> Swift.Bool
  final public class func start(_ config: ATOMTouchConfiguration = ATOMTouchConfiguration())
  final public class func stop()
  final public class func getTouches() -> [UIKit.UITouch]
  final public func handleEvent(_ event: UIKit.UIEvent)
}
extension ATOMVisualizer {
  final public func log(_ touch: UIKit.UITouch)
}
public protocol ATOMDeviceTrackManagerProtocol {
  func saveDeviceData()
}
@_hasMissingDesignatedInitializers public class ATOMRefreshData {
  public static let shared: ATOMRefreshData
  public var cohortsUpdatedAt: Swift.String {
    get
    set
  }
  public var signalsSavedInLocalDatabaseAt: Swift.String {
    get
    set
  }
  public var initialSignalsSavedInLocalDatabaseAt: Swift.String {
    get
    set
  }
  @objc deinit
}
extension Foundation.Data : DatabaseValueConvertible, StatementColumnConvertible {
  @inlinable public init(sqliteStatement: SQLiteStatement, index: Swift.Int32) {
        if let bytes = sqlite3_column_blob(sqliteStatement, index) {
            let count = Int(sqlite3_column_bytes(sqliteStatement, index))
            self.init(bytes: bytes, count: count)  
        } else {
            self.init()
        }
    }
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Foundation.Data?
}
public struct ResultCode : Swift.RawRepresentable, Swift.Equatable, Swift.CustomStringConvertible {
  public let rawValue: Swift.Int32
  public init(rawValue: Swift.Int32)
  public var primaryResultCode: ResultCode {
    get
  }
  public static func ~= (pattern: ResultCode, code: ResultCode) -> Swift.Bool
  public static let SQLITE_OK: ResultCode
  public static let SQLITE_ERROR: ResultCode
  public static let SQLITE_INTERNAL: ResultCode
  public static let SQLITE_PERM: ResultCode
  public static let SQLITE_ABORT: ResultCode
  public static let SQLITE_BUSY: ResultCode
  public static let SQLITE_LOCKED: ResultCode
  public static let SQLITE_NOMEM: ResultCode
  public static let SQLITE_READONLY: ResultCode
  public static let SQLITE_INTERRUPT: ResultCode
  public static let SQLITE_IOERR: ResultCode
  public static let SQLITE_CORRUPT: ResultCode
  public static let SQLITE_NOTFOUND: ResultCode
  public static let SQLITE_FULL: ResultCode
  public static let SQLITE_CANTOPEN: ResultCode
  public static let SQLITE_PROTOCOL: ResultCode
  public static let SQLITE_EMPTY: ResultCode
  public static let SQLITE_SCHEMA: ResultCode
  public static let SQLITE_TOOBIG: ResultCode
  public static let SQLITE_CONSTRAINT: ResultCode
  public static let SQLITE_MISMATCH: ResultCode
  public static let SQLITE_MISUSE: ResultCode
  public static let SQLITE_NOLFS: ResultCode
  public static let SQLITE_AUTH: ResultCode
  public static let SQLITE_FORMAT: ResultCode
  public static let SQLITE_RANGE: ResultCode
  public static let SQLITE_NOTADB: ResultCode
  public static let SQLITE_NOTICE: ResultCode
  public static let SQLITE_WARNING: ResultCode
  public static let SQLITE_ROW: ResultCode
  public static let SQLITE_DONE: ResultCode
  public static let SQLITE_ERROR_MISSING_COLLSEQ: ResultCode
  public static let SQLITE_ERROR_RETRY: ResultCode
  public static let SQLITE_ERROR_SNAPSHOT: ResultCode
  public static let SQLITE_IOERR_READ: ResultCode
  public static let SQLITE_IOERR_SHORT_READ: ResultCode
  public static let SQLITE_IOERR_WRITE: ResultCode
  public static let SQLITE_IOERR_FSYNC: ResultCode
  public static let SQLITE_IOERR_DIR_FSYNC: ResultCode
  public static let SQLITE_IOERR_TRUNCATE: ResultCode
  public static let SQLITE_IOERR_FSTAT: ResultCode
  public static let SQLITE_IOERR_UNLOCK: ResultCode
  public static let SQLITE_IOERR_RDLOCK: ResultCode
  public static let SQLITE_IOERR_DELETE: ResultCode
  public static let SQLITE_IOERR_BLOCKED: ResultCode
  public static let SQLITE_IOERR_NOMEM: ResultCode
  public static let SQLITE_IOERR_ACCESS: ResultCode
  public static let SQLITE_IOERR_CHECKRESERVEDLOCK: ResultCode
  public static let SQLITE_IOERR_LOCK: ResultCode
  public static let SQLITE_IOERR_CLOSE: ResultCode
  public static let SQLITE_IOERR_DIR_CLOSE: ResultCode
  public static let SQLITE_IOERR_SHMOPEN: ResultCode
  public static let SQLITE_IOERR_SHMSIZE: ResultCode
  public static let SQLITE_IOERR_SHMLOCK: ResultCode
  public static let SQLITE_IOERR_SHMMAP: ResultCode
  public static let SQLITE_IOERR_SEEK: ResultCode
  public static let SQLITE_IOERR_DELETE_NOENT: ResultCode
  public static let SQLITE_IOERR_MMAP: ResultCode
  public static let SQLITE_IOERR_GETTEMPPATH: ResultCode
  public static let SQLITE_IOERR_CONVPATH: ResultCode
  public static let SQLITE_IOERR_VNODE: ResultCode
  public static let SQLITE_IOERR_AUTH: ResultCode
  public static let SQLITE_IOERR_BEGIN_ATOMIC: ResultCode
  public static let SQLITE_IOERR_COMMIT_ATOMIC: ResultCode
  public static let SQLITE_IOERR_ROLLBACK_ATOMIC: ResultCode
  public static let SQLITE_LOCKED_SHAREDCACHE: ResultCode
  public static let SQLITE_LOCKED_VTAB: ResultCode
  public static let SQLITE_BUSY_RECOVERY: ResultCode
  public static let SQLITE_BUSY_SNAPSHOT: ResultCode
  public static let SQLITE_CANTOPEN_NOTEMPDIR: ResultCode
  public static let SQLITE_CANTOPEN_ISDIR: ResultCode
  public static let SQLITE_CANTOPEN_FULLPATH: ResultCode
  public static let SQLITE_CANTOPEN_CONVPATH: ResultCode
  public static let SQLITE_CANTOPEN_DIRTYWAL: ResultCode
  public static let SQLITE_CORRUPT_VTAB: ResultCode
  public static let SQLITE_CORRUPT_SEQUENCE: ResultCode
  public static let SQLITE_READONLY_RECOVERY: ResultCode
  public static let SQLITE_READONLY_CANTLOCK: ResultCode
  public static let SQLITE_READONLY_ROLLBACK: ResultCode
  public static let SQLITE_READONLY_DBMOVED: ResultCode
  public static let SQLITE_READONLY_CANTINIT: ResultCode
  public static let SQLITE_READONLY_DIRECTORY: ResultCode
  public static let SQLITE_ABORT_ROLLBACK: ResultCode
  public static let SQLITE_CONSTRAINT_CHECK: ResultCode
  public static let SQLITE_CONSTRAINT_COMMITHOOK: ResultCode
  public static let SQLITE_CONSTRAINT_FOREIGNKEY: ResultCode
  public static let SQLITE_CONSTRAINT_FUNCTION: ResultCode
  public static let SQLITE_CONSTRAINT_NOTNULL: ResultCode
  public static let SQLITE_CONSTRAINT_PRIMARYKEY: ResultCode
  public static let SQLITE_CONSTRAINT_TRIGGER: ResultCode
  public static let SQLITE_CONSTRAINT_UNIQUE: ResultCode
  public static let SQLITE_CONSTRAINT_VTAB: ResultCode
  public static let SQLITE_CONSTRAINT_ROWID: ResultCode
  public static let SQLITE_NOTICE_RECOVER_WAL: ResultCode
  public static let SQLITE_NOTICE_RECOVER_ROLLBACK: ResultCode
  public static let SQLITE_WARNING_AUTOINDEX: ResultCode
  public static let SQLITE_AUTH_USER: ResultCode
  public static let SQLITE_OK_LOAD_PERMANENTLY: ResultCode
  public typealias RawValue = Swift.Int32
}
extension ResultCode {
  public var description: Swift.String {
    get
  }
}
public struct DatabaseError : Swift.Error, Swift.CustomStringConvertible, Foundation.CustomNSError {
  public var resultCode: ResultCode {
    get
  }
  public let extendedResultCode: ResultCode
  public let message: Swift.String?
  public let sql: Swift.String?
  public init(resultCode: ResultCode = .SQLITE_ERROR, message: Swift.String? = nil, sql: Swift.String? = nil, arguments: StatementArguments? = nil)
}
extension DatabaseError {
  public var isInterruptionError: Swift.Bool {
    get
  }
}
extension DatabaseError {
  public var description: Swift.String {
    get
  }
}
extension DatabaseError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public struct ATOMGestureObject {
}
extension Database {
  final public func add(transactionObserver: any TransactionObserver, extent: Database.TransactionObservationExtent = .observerLifetime)
  final public func remove(transactionObserver: any TransactionObserver)
  final public func afterNextTransactionCommit(_ closure: @escaping (Database) -> Swift.Void)
  public enum TransactionObservationExtent {
    case observerLifetime
    case nextTransaction
    case databaseLifetime
    public static func == (a: Database.TransactionObservationExtent, b: Database.TransactionObservationExtent) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol TransactionObserver : AnyObject {
  func observes(eventsOfKind eventKind: DatabaseEventKind) -> Swift.Bool
  func databaseDidChange(with event: DatabaseEvent)
  func databaseWillCommit() throws
  func databaseDidCommit(_ db: Database)
  func databaseDidRollback(_ db: Database)
}
extension TransactionObserver {
  public func databaseWillCommit() throws
  public func stopObservingDatabaseChangesUntilNextTransaction()
}
public enum DatabaseEventKind {
  case insert(tableName: Swift.String)
  case delete(tableName: Swift.String)
  case update(tableName: Swift.String, columnNames: Swift.Set<Swift.String>)
}
extension DatabaseEventKind {
  public var tableName: Swift.String {
    get
  }
}
public struct DatabaseEvent {
  public enum Kind : Swift.Int32 {
    case insert
    case delete
    case update
    public init?(rawValue: Swift.Int32)
    public typealias RawValue = Swift.Int32
    public var rawValue: Swift.Int32 {
      get
    }
  }
  public let kind: DatabaseEvent.Kind
  public var databaseName: Swift.String {
    get
  }
  public var tableName: Swift.String {
    get
  }
  public let rowID: Swift.Int64
  public func copy() -> DatabaseEvent
}
extension Foundation.NSString : DatabaseValueConvertible {
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Self?
}
public protocol ATOMSignalsProviderProtocol {
  var batteryManager: any ATOMBatteryManagerProtocol { get }
  var reachabilityManager: any ATOMReachabilityManagerProtocol { get }
  var luminosityManager: any ATOMLuminosityManagerProtocol { get }
  var signalTrackManager: any ATOMSignalTrackManagerProtocol { get }
}
@_hasMissingDesignatedInitializers final public class Row : Swift.Equatable, Swift.Hashable, Swift.RandomAccessCollection, Swift.ExpressibleByDictionaryLiteral, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  @usableFromInline
  final internal let statement: SelectStatement?
  @usableFromInline
  final internal let sqliteStatement: SQLiteStatement?
  final public let count: Swift.Int
  final public var prefetchedRows: Row.PrefetchedRowsView {
    get
  }
  convenience public init()
  convenience public init(_ dictionary: [Swift.String : (any DatabaseValueConvertible)?])
  convenience public init?(_ dictionary: [Swift.AnyHashable : Any])
  final public func copy() -> Row
  public typealias Element = (Swift.String, DatabaseValue)
  public typealias Index = RowIndex
  public typealias Indices = Swift.Range<RowIndex>
  public typealias Iterator = Swift.IndexingIterator<Row>
  public typealias Key = Swift.String
  public typealias SubSequence = Swift.Slice<Row>
  public typealias Value = (any DatabaseValueConvertible)?
  @objc deinit
  final public var hashValue: Swift.Int {
    get
  }
}
extension Row {
  final public var columnNames: Swift.LazyMapCollection<Row, Swift.String> {
    get
  }
  final public func hasColumn(_ columnName: Swift.String) -> Swift.Bool
  @usableFromInline
  final internal func index(ofColumn name: Swift.String) -> Swift.Int?
}
extension Row {
  @inlinable final internal func _checkIndex(_ index: Swift.Int, file: Swift.StaticString = #file, line: Swift.UInt = #line) {
        GRDBPrecondition(index >= 0 && index < count, "row index out of range", file: file, line: line)
    }
  final public var containsNonNullValue: Swift.Bool {
    get
  }
  final public func hasNull(atIndex index: Swift.Int) -> Swift.Bool
  final public subscript(index: Swift.Int) -> (any DatabaseValueConvertible)? {
    get
  }
  @inlinable final public subscript<Value>(index: Swift.Int) -> Value? where Value : DatabaseValueConvertible {
    get {
        _checkIndex(index)
        return Value.decodeIfPresent(from: self, atUncheckedIndex: index)
    }
  }
  @inlinable final public subscript<Value>(index: Swift.Int) -> Value? where Value : DatabaseValueConvertible, Value : StatementColumnConvertible {
    get {
        _checkIndex(index)
        return Value.fastDecodeIfPresent(from: self, atUncheckedIndex: index)
    }
  }
  @inlinable final public subscript<Value>(index: Swift.Int) -> Value where Value : DatabaseValueConvertible {
    get {
        _checkIndex(index)
        return Value.decode(from: self, atUncheckedIndex: index)
    }
  }
  @inlinable final public subscript<Value>(index: Swift.Int) -> Value where Value : DatabaseValueConvertible, Value : StatementColumnConvertible {
    get {
        _checkIndex(index)
        return Value.fastDecode(from: self, atUncheckedIndex: index)
    }
  }
  final public subscript(columnName: Swift.String) -> (any DatabaseValueConvertible)? {
    get
  }
  @inlinable final public subscript<Value>(columnName: Swift.String) -> Value? where Value : DatabaseValueConvertible {
    get {
        guard let index = index(ofColumn: columnName) else {
            return nil
        }
        return Value.decodeIfPresent(from: self, atUncheckedIndex: index)
    }
  }
  @inlinable final public subscript<Value>(columnName: Swift.String) -> Value? where Value : DatabaseValueConvertible, Value : StatementColumnConvertible {
    get {
        guard let index = index(ofColumn: columnName) else {
            return nil
        }
        return Value.fastDecodeIfPresent(from: self, atUncheckedIndex: index)
    }
  }
  @inlinable final public subscript<Value>(columnName: Swift.String) -> Value where Value : DatabaseValueConvertible {
    get {
        guard let index = index(ofColumn: columnName) else {
             
            fatalConversionError(to: Value.self, from: nil, in: self, atColumn: columnName)
        }
        return Value.decode(from: self, atUncheckedIndex: index)
    }
  }
  @inlinable final public subscript<Value>(columnName: Swift.String) -> Value where Value : DatabaseValueConvertible, Value : StatementColumnConvertible {
    get {
        guard let index = index(ofColumn: columnName) else {
             
            fatalConversionError(to: Value.self, from: nil, in: self, atColumn: columnName)
        }
        return Value.fastDecode(from: self, atUncheckedIndex: index)
    }
  }
  @inlinable final public subscript<Column>(column: Column) -> (any DatabaseValueConvertible)? where Column : ColumnExpression {
    get {
        return self[column.name]
    }
  }
  @inlinable final public subscript<Value, Column>(column: Column) -> Value? where Value : DatabaseValueConvertible, Column : ColumnExpression {
    get {
        return self[column.name]
    }
  }
  @inlinable final public subscript<Value, Column>(column: Column) -> Value? where Value : DatabaseValueConvertible, Value : StatementColumnConvertible, Column : ColumnExpression {
    get {
        return self[column.name]
    }
  }
  @inlinable final public subscript<Value, Column>(column: Column) -> Value where Value : DatabaseValueConvertible, Column : ColumnExpression {
    get {
        return self[column.name]
    }
  }
  @inlinable final public subscript<Value, Column>(column: Column) -> Value where Value : DatabaseValueConvertible, Value : StatementColumnConvertible, Column : ColumnExpression {
    get {
        return self[column.name]
    }
  }
  final public func dataNoCopy(atIndex index: Swift.Int) -> Foundation.Data?
  final public func dataNoCopy(named columnName: Swift.String) -> Foundation.Data?
  final public func dataNoCopy<Column>(_ column: Column) -> Foundation.Data? where Column : ColumnExpression
}
extension Row {
  final public var databaseValues: Swift.LazyMapCollection<Row, DatabaseValue> {
    get
  }
}
extension Row {
  final public subscript<Record>(scope: Swift.String) -> Record where Record : FetchableRecord {
    get
  }
  final public subscript<Record>(scope: Swift.String) -> Record? where Record : FetchableRecord {
    get
  }
  final public subscript<Collection>(key: Swift.String) -> Collection where Collection : Swift.RangeReplaceableCollection, Collection.Element : FetchableRecord {
    get
  }
  final public subscript<Record>(key: Swift.String) -> Swift.Set<Record> where Record : FetchableRecord, Record : Swift.Hashable {
    get
  }
}
extension Row {
  final public var scopes: Row.ScopesView {
    get
  }
  final public var scopesTree: Row.ScopesTreeView {
    get
  }
  final public var unscoped: Row {
    get
  }
  final public var unadapted: Row {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RowCursor : Cursor {
  final public let statement: SelectStatement
  @usableFromInline
  final internal let _sqliteStatement: SQLiteStatement
  @usableFromInline
  final internal let _row: Row
  @usableFromInline
  final internal var _done: Swift.Bool
  @objc deinit
  @inlinable final public func next() throws -> Row? {
        if _done {
             
             
            return nil
        }
        switch sqlite3_step(_sqliteStatement) {
        case SQLITE_DONE:
            _done = true
            return nil
        case SQLITE_ROW:
            return _row
        case let code:
            try statement.didFail(withResultCode: code)
        }
    }
  public typealias Element = Row
}
extension Row {
  public static func fetchCursor(_ statement: SelectStatement, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> RowCursor
  public static func fetchAll(_ statement: SelectStatement, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> [Row]
  public static func fetchOne(_ statement: SelectStatement, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> Row?
}
extension Row {
  public static func fetchCursor(_ db: Database, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil) throws -> RowCursor
  public static func fetchAll(_ db: Database, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil) throws -> [Row]
  public static func fetchOne(_ db: Database, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil) throws -> Row?
}
extension Row {
  public static func fetchCursor<R>(_ db: Database, _ request: R) throws -> RowCursor where R : FetchRequest
  public static func fetchAll<R>(_ db: Database, _ request: R) throws -> [Row] where R : FetchRequest
  public static func fetchOne<R>(_ db: Database, _ request: R) throws -> Row? where R : FetchRequest
}
extension FetchRequest where Self.RowDecoder == Row {
  public func fetchCursor(_ db: Database) throws -> RowCursor
  public func fetchAll(_ db: Database) throws -> [Row]
  public func fetchOne(_ db: Database) throws -> Row?
}
extension Row {
  convenience public init(dictionaryLiteral elements: (Swift.String, (any DatabaseValueConvertible)?)...)
}
extension Row {
  final public var startIndex: RowIndex {
    get
  }
  final public var endIndex: RowIndex {
    get
  }
  final public subscript(position: RowIndex) -> (Swift.String, DatabaseValue) {
    get
  }
}
extension Row {
  public static func == (lhs: Row, rhs: Row) -> Swift.Bool
}
extension Row {
  final public func hash(into hasher: inout Swift.Hasher)
}
extension Row {
  final public var description: Swift.String {
    get
  }
  final public var debugDescription: Swift.String {
    get
  }
}
public struct RowIndex : Swift.Comparable, Swift.Strideable {
  public typealias Stride = Swift.Int
}
extension RowIndex {
  public static func == (lhs: RowIndex, rhs: RowIndex) -> Swift.Bool
  public static func < (lhs: RowIndex, rhs: RowIndex) -> Swift.Bool
}
extension RowIndex {
  public func distance(to other: RowIndex) -> Swift.Int
  public func advanced(by n: Swift.Int) -> RowIndex
}
extension Row {
  public struct ScopesView : Swift.Collection {
    public typealias Index = Swift.Dictionary<Swift.String, any LayoutedRowAdapter>.Index
    public var names: Swift.Dictionary<Swift.String, any LayoutedRowAdapter>.Keys {
      get
    }
    public var startIndex: Row.ScopesView.Index {
      get
    }
    public var endIndex: Row.ScopesView.Index {
      get
    }
    public func index(after i: Row.ScopesView.Index) -> Row.ScopesView.Index
    public subscript(position: Row.ScopesView.Index) -> (name: Swift.String, row: Row) {
      get
    }
    public subscript(name: Swift.String) -> Row? {
      get
    }
    public typealias Element = (name: Swift.String, row: Row)
    public typealias Indices = Swift.DefaultIndices<Row.ScopesView>
    public typealias Iterator = Swift.IndexingIterator<Row.ScopesView>
    public typealias SubSequence = Swift.Slice<Row.ScopesView>
  }
}
extension Row {
  public struct ScopesTreeView {
    public var names: Swift.Set<Swift.String> {
      get
    }
    public subscript(name: Swift.String) -> Row? {
      get
    }
  }
}
extension Row {
  public struct PrefetchedRowsView : Swift.Equatable {
    public var isEmpty: Swift.Bool {
      get
    }
    public var keys: Swift.Set<Swift.String> {
      get
    }
    public subscript(key: Swift.String) -> [Row]? {
      get
    }
    public static func == (a: Row.PrefetchedRowsView, b: Row.PrefetchedRowsView) -> Swift.Bool
  }
}
public struct Configuration {
  public var foreignKeysEnabled: Swift.Bool
  public var readonly: Swift.Bool
  public var label: Swift.String?
  public var trace: TraceFunction?
  public var acceptsDoubleQuotedStringLiterals: Swift.Bool
  public var observesSuspensionNotifications: Swift.Bool
  public var prepareDatabase: ((Database) throws -> Swift.Void)?
  public var defaultTransactionKind: Database.TransactionKind
  public var allowsUnsafeTransactions: Swift.Bool
  public var busyMode: Database.BusyMode
  public var maximumReaderCount: Swift.Int
  public var qos: Dispatch.DispatchQoS
  public var targetQueue: Dispatch.DispatchQueue?
  public init()
}
public typealias TraceFunction = (Swift.String) -> Swift.Void
extension DatabaseValueConvertible where Self : Swift.RawRepresentable, Self.RawValue : DatabaseValueConvertible {
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Self?
}
public protocol SQLExpression : SQLOrderingTerm, SQLSelectable, SQLSpecificExpressible {
  func expressionSQL(_ context: inout SQLGenerationContext, wrappedInParenthesis: Swift.Bool) -> Swift.String
  var negated: any SQLExpression { get }
  func matchedRowIds(rowIdName: Swift.String?) -> Swift.Set<Swift.Int64>?
  func qualifiedExpression(with alias: TableAlias) -> any SQLExpression
}
extension SQLExpression {
  public var negated: any SQLExpression {
    get
  }
  public func matchedRowIds(rowIdName: Swift.String?) -> Swift.Set<Swift.Int64>?
  public func qualifiedSelectable(with alias: TableAlias) -> any SQLSelectable
  public func qualifiedOrdering(with alias: TableAlias) -> any SQLOrderingTerm
}
extension SQLExpression {
  public var sqlExpression: any SQLExpression {
    get
  }
}
extension SQLExpression {
  public func count(distinct: Swift.Bool) -> SQLCount?
}
public enum ATOMReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension Foundation.NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class ATOMReachability {
  public typealias NetworkReachable = (ATOMReachability) -> ()
  public typealias NetworkUnreachable = (ATOMReachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: ATOMReachability.NetworkStatus, b: ATOMReachability.NetworkStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible {
    case unavailable, wifi, cellular
    public var description: Swift.String {
      get
    }
    @available(*, deprecated, renamed: "unavailable")
    public static let none: ATOMReachability.Connection
    public static func == (a: ATOMReachability.Connection, b: ATOMReachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: ATOMReachability.NetworkReachable?
  public var whenUnreachable: ATOMReachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: ATOMReachability.Connection {
    get
  }
  public var connection: ATOMReachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  convenience public init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  convenience public init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension ATOMReachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
public struct Inflections {
  public init()
  public mutating func plural(_ pattern: Swift.String, options: Foundation.NSRegularExpression.Options = [.caseInsensitive], _ template: Swift.String)
  public mutating func singular(_ pattern: Swift.String, options: Foundation.NSRegularExpression.Options = [.caseInsensitive], _ template: Swift.String)
  public mutating func uncountableWords(_ words: [Swift.String])
  public mutating func irregularSuffix(_ singular: Swift.String, _ plural: Swift.String)
  public func pluralize(_ string: Swift.String) -> Swift.String
  public func singularize(_ string: Swift.String) -> Swift.String
}
extension Foundation.NSNumber : DatabaseValueConvertible {
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Self?
}
extension Foundation.NSUUID : DatabaseValueConvertible {
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Self?
}
extension Foundation.UUID : DatabaseValueConvertible {
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Foundation.UUID?
}
extension Foundation.UUID : StatementColumnConvertible {
  @inlinable public init(sqliteStatement: SQLiteStatement, index: Swift.Int32) {
        switch sqlite3_column_type(sqliteStatement, index) {
        case SQLITE_TEXT:
            let string = String(cString: sqlite3_column_text(sqliteStatement, index)!)
            guard let uuid = UUID(uuidString: string) else {
                fatalConversionError(to: UUID.self, sqliteStatement: sqliteStatement, index: index)
            }
            self.init(uuid: uuid.uuid)
        case SQLITE_BLOB:
            guard sqlite3_column_bytes(sqliteStatement, index) == 16,
                let blob = sqlite3_column_blob(sqliteStatement, index) else
            {
                fatalConversionError(to: UUID.self, sqliteStatement: sqliteStatement, index: index)
            }
            self.init(uuid: blob.assumingMemoryBound(to: uuid_t.self).pointee)
        default:
            fatalConversionError(to: UUID.self, sqliteStatement: sqliteStatement, index: index)
        }
    }
}
public struct ATOMGyroscopeSignalDBO {
}
extension Foundation.NSData : DatabaseValueConvertible {
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Self?
}
public enum ATOMFeatureState : Swift.Codable {
  case pending
  case inProgress
  case ready
  case error
  public static func == (a: ATOMFeatureState, b: ATOMFeatureState) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct ATOMFeature : Swift.Codable {
  public let id: Swift.Int
  public let tableName: Swift.String
  public let query: Swift.String
  public let initialCalculationRateInSeconds: Swift.Int
  public let cyclicCalculationRateInSeconds: Swift.Int
  public var state: ATOMFeatureState {
    get
  }
  public mutating func calculationStarted()
  public mutating func calculationFinished()
  public mutating func calculationFailed()
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DatabaseDateComponents : DatabaseValueConvertible, StatementColumnConvertible, Swift.Codable {
  public enum Format : Swift.String {
    case YMD
    case YMD_HM
    case YMD_HMS
    case YMD_HMSS
    case HM
    case HMS
    case HMSS
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let dateComponents: Foundation.DateComponents
  public let format: DatabaseDateComponents.Format
  public init(_ dateComponents: Foundation.DateComponents, format: DatabaseDateComponents.Format)
  public init(sqliteStatement: SQLiteStatement, index: Swift.Int32)
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> DatabaseDateComponents?
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct ForeignKey {
  public init(_ originColumns: [Swift.String], to destinationColumns: [Swift.String]? = nil)
  public init(_ originColumns: [any ColumnExpression], to destinationColumns: [any ColumnExpression]? = nil)
}
extension Swift.Bool : DatabaseValueConvertible, StatementColumnConvertible {
  @inlinable public init(sqliteStatement: SQLiteStatement, index: Swift.Int32) {
        self = sqlite3_column_int64(sqliteStatement, index) != 0
    }
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Swift.Bool?
}
extension Swift.Int : DatabaseValueConvertible, StatementColumnConvertible {
  @inlinable public init(sqliteStatement: SQLiteStatement, index: Swift.Int32) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        if let v = Int(exactly: int64) {
            self = v
        } else {
            fatalConversionError(to: Int.self, sqliteStatement: sqliteStatement, index: index)
        }
    }
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Swift.Int?
}
extension Swift.Int8 : DatabaseValueConvertible, StatementColumnConvertible {
  @inlinable public init(sqliteStatement: SQLiteStatement, index: Swift.Int32) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        if let v = Int8(exactly: int64) {
            self = v
        } else {
            fatalConversionError(to: Int8.self, sqliteStatement: sqliteStatement, index: index)
        }
    }
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Swift.Int8?
}
extension Swift.Int16 : DatabaseValueConvertible, StatementColumnConvertible {
  @inlinable public init(sqliteStatement: SQLiteStatement, index: Swift.Int32) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        if let v = Int16(exactly: int64) {
            self = v
        } else {
            fatalConversionError(to: Int16.self, sqliteStatement: sqliteStatement, index: index)
        }
    }
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Swift.Int16?
}
extension Swift.Int32 : DatabaseValueConvertible, StatementColumnConvertible {
  @inlinable public init(sqliteStatement: SQLiteStatement, index: Swift.Int32) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        if let v = Int32(exactly: int64) {
            self = v
        } else {
            fatalConversionError(to: Int32.self, sqliteStatement: sqliteStatement, index: index)
        }
    }
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Swift.Int32?
}
extension Swift.Int64 : DatabaseValueConvertible, StatementColumnConvertible {
  @inlinable public init(sqliteStatement: SQLiteStatement, index: Swift.Int32) {
        self = sqlite3_column_int64(sqliteStatement, index)
    }
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Swift.Int64?
}
extension Swift.UInt : DatabaseValueConvertible, StatementColumnConvertible {
  @inlinable public init(sqliteStatement: SQLiteStatement, index: Swift.Int32) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        if let v = UInt(exactly: int64) {
            self = v
        } else {
            fatalConversionError(to: UInt.self, sqliteStatement: sqliteStatement, index: index)
        }
    }
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Swift.UInt?
}
extension Swift.UInt8 : DatabaseValueConvertible, StatementColumnConvertible {
  @inlinable public init(sqliteStatement: SQLiteStatement, index: Swift.Int32) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        if let v = UInt8(exactly: int64) {
            self = v
        } else {
            fatalConversionError(to: UInt8.self, sqliteStatement: sqliteStatement, index: index)
        }
    }
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Swift.UInt8?
}
extension Swift.UInt16 : DatabaseValueConvertible, StatementColumnConvertible {
  @inlinable public init(sqliteStatement: SQLiteStatement, index: Swift.Int32) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        if let v = UInt16(exactly: int64) {
            self = v
        } else {
            fatalConversionError(to: UInt16.self, sqliteStatement: sqliteStatement, index: index)
        }
    }
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Swift.UInt16?
}
extension Swift.UInt32 : DatabaseValueConvertible, StatementColumnConvertible {
  @inlinable public init(sqliteStatement: SQLiteStatement, index: Swift.Int32) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        if let v = UInt32(exactly: int64) {
            self = v
        } else {
            fatalConversionError(to: UInt32.self, sqliteStatement: sqliteStatement, index: index)
        }
    }
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Swift.UInt32?
}
extension Swift.UInt64 : DatabaseValueConvertible, StatementColumnConvertible {
  @inlinable public init(sqliteStatement: SQLiteStatement, index: Swift.Int32) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        if let v = UInt64(exactly: int64) {
            self = v
        } else {
            fatalConversionError(to: UInt64.self, sqliteStatement: sqliteStatement, index: index)
        }
    }
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Swift.UInt64?
}
extension Swift.Double : DatabaseValueConvertible, StatementColumnConvertible {
  @inlinable public init(sqliteStatement: SQLiteStatement, index: Swift.Int32) {
        self = sqlite3_column_double(sqliteStatement, index)
    }
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Swift.Double?
}
extension Swift.Float : DatabaseValueConvertible, StatementColumnConvertible {
  @inlinable public init(sqliteStatement: SQLiteStatement, index: Swift.Int32) {
        self = Float(sqlite3_column_double(sqliteStatement, index))
    }
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Swift.Float?
}
extension Swift.String : DatabaseValueConvertible, StatementColumnConvertible {
  @inlinable public init(sqliteStatement: SQLiteStatement, index: Swift.Int32) {
        self = String(cString: sqlite3_column_text(sqliteStatement, index)!)
    }
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Swift.String?
}
public struct AllColumns {
  public init()
}
extension AllColumns : SQLSelectable {
  public func resultColumnSQL(_ context: inout SQLGenerationContext) -> Swift.String
  public func countedSQL(_ context: inout SQLGenerationContext) -> Swift.String
  public func count(distinct: Swift.Bool) -> SQLCount?
  public func qualifiedSelectable(with alias: TableAlias) -> any SQLSelectable
  public func columnCount(_ db: Database) throws -> Swift.Int
}
@usableFromInline
internal func fatalConversionError<T>(to: T.Type, from dbValue: DatabaseValue?, in row: Row, atColumn columnName: Swift.String, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never
@usableFromInline
internal func fatalConversionError<T>(to: T.Type, sqliteStatement: SQLiteStatement, index: Swift.Int32, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never
@usableFromInline
internal func fatalConversionError<T>(to: T.Type, from dbValue: DatabaseValue?, sqliteStatement: SQLiteStatement, index: Swift.Int32, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> Swift.Never
extension DatabaseValueConvertible {
  @usableFromInline
  internal static func decode(from sqliteStatement: SQLiteStatement, atUncheckedIndex index: Swift.Int32) -> Self
  @usableFromInline
  internal static func decode(from row: Row, atUncheckedIndex index: Swift.Int) -> Self
  @usableFromInline
  internal static func decodeIfPresent(from sqliteStatement: SQLiteStatement, atUncheckedIndex index: Swift.Int32) -> Self?
  @usableFromInline
  internal static func decodeIfPresent(from row: Row, atUncheckedIndex index: Swift.Int) -> Self?
}
extension DatabaseValueConvertible where Self : StatementColumnConvertible {
  @inlinable internal static func fastDecode(from sqliteStatement: SQLiteStatement, atUncheckedIndex index: Swift.Int32) -> Self {
        if sqlite3_column_type(sqliteStatement, index) == SQLITE_NULL {
            fatalConversionError(to: Self.self, sqliteStatement: sqliteStatement, index: index)
        }
        return self.init(sqliteStatement: sqliteStatement, index: index)
    }
  @inlinable internal static func fastDecode(from row: Row, atUncheckedIndex index: Swift.Int) -> Self {
        if let sqliteStatement = row.sqliteStatement {
            return fastDecode(from: sqliteStatement, atUncheckedIndex: Int32(index))
        }
        return row.fastDecode(Self.self, atUncheckedIndex: index)
    }
  @inlinable internal static func fastDecodeIfPresent(from sqliteStatement: SQLiteStatement, atUncheckedIndex index: Swift.Int32) -> Self? {
        if sqlite3_column_type(sqliteStatement, index) == SQLITE_NULL {
            return nil
        }
        return self.init(sqliteStatement: sqliteStatement, index: index)
    }
  @inlinable internal static func fastDecodeIfPresent(from row: Row, atUncheckedIndex index: Swift.Int) -> Self? {
        if let sqliteStatement = row.sqliteStatement {
            return fastDecodeIfPresent(from: sqliteStatement, atUncheckedIndex: Int32(index))
        }
        return row.fastDecodeIfPresent(Self.self, atUncheckedIndex: index)
    }
}
extension Row {
  @usableFromInline
  final internal func fastDecode<Value>(_ type: Value.Type, atUncheckedIndex index: Swift.Int) -> Value where Value : DatabaseValueConvertible, Value : StatementColumnConvertible
  @usableFromInline
  final internal func fastDecodeIfPresent<Value>(_ type: Value.Type, atUncheckedIndex index: Swift.Int) -> Value? where Value : DatabaseValueConvertible, Value : StatementColumnConvertible
}
public func == (lhs: any SQLSpecificExpressible, rhs: (any SQLExpressible)?) -> any SQLExpression
public func == (lhs: SQLCollatedExpression, rhs: (any SQLExpressible)?) -> any SQLExpression
public func == (lhs: any SQLSpecificExpressible, rhs: Swift.Bool) -> any SQLExpression
public func == (lhs: (any SQLExpressible)?, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func == (lhs: (any SQLExpressible)?, rhs: SQLCollatedExpression) -> any SQLExpression
public func == (lhs: Swift.Bool, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func == (lhs: any SQLSpecificExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func != (lhs: any SQLSpecificExpressible, rhs: (any SQLExpressible)?) -> any SQLExpression
public func != (lhs: SQLCollatedExpression, rhs: (any SQLExpressible)?) -> any SQLExpression
public func != (lhs: any SQLSpecificExpressible, rhs: Swift.Bool) -> any SQLExpression
public func != (lhs: (any SQLExpressible)?, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func != (lhs: (any SQLExpressible)?, rhs: SQLCollatedExpression) -> any SQLExpression
public func != (lhs: Swift.Bool, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func != (lhs: any SQLSpecificExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func === (lhs: any SQLSpecificExpressible, rhs: (any SQLExpressible)?) -> any SQLExpression
public func === (lhs: SQLCollatedExpression, rhs: (any SQLExpressible)?) -> any SQLExpression
public func === (lhs: (any SQLExpressible)?, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func === (lhs: (any SQLExpressible)?, rhs: SQLCollatedExpression) -> any SQLExpression
public func === (lhs: any SQLSpecificExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func !== (lhs: any SQLSpecificExpressible, rhs: (any SQLExpressible)?) -> any SQLExpression
public func !== (lhs: SQLCollatedExpression, rhs: (any SQLExpressible)?) -> any SQLExpression
public func !== (lhs: (any SQLExpressible)?, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func !== (lhs: (any SQLExpressible)?, rhs: SQLCollatedExpression) -> any SQLExpression
public func !== (lhs: any SQLSpecificExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func < (lhs: any SQLSpecificExpressible, rhs: any SQLExpressible) -> any SQLExpression
public func < (lhs: SQLCollatedExpression, rhs: any SQLExpressible) -> any SQLExpression
public func < (lhs: any SQLExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func < (lhs: any SQLExpressible, rhs: SQLCollatedExpression) -> any SQLExpression
public func < (lhs: any SQLSpecificExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func <= (lhs: any SQLSpecificExpressible, rhs: any SQLExpressible) -> any SQLExpression
public func <= (lhs: SQLCollatedExpression, rhs: any SQLExpressible) -> any SQLExpression
public func <= (lhs: any SQLExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func <= (lhs: any SQLExpressible, rhs: SQLCollatedExpression) -> any SQLExpression
public func <= (lhs: any SQLSpecificExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func > (lhs: any SQLSpecificExpressible, rhs: any SQLExpressible) -> any SQLExpression
public func > (lhs: SQLCollatedExpression, rhs: any SQLExpressible) -> any SQLExpression
public func > (lhs: any SQLExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func > (lhs: any SQLExpressible, rhs: SQLCollatedExpression) -> any SQLExpression
public func > (lhs: any SQLSpecificExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func >= (lhs: any SQLSpecificExpressible, rhs: any SQLExpressible) -> any SQLExpression
public func >= (lhs: SQLCollatedExpression, rhs: any SQLExpressible) -> any SQLExpression
public func >= (lhs: any SQLExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func >= (lhs: any SQLExpressible, rhs: SQLCollatedExpression) -> any SQLExpression
public func >= (lhs: any SQLSpecificExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
extension Swift.Range where Bound : SQLExpressible {
  public func contains(_ element: any SQLSpecificExpressible) -> any SQLExpression
  public func contains(_ element: SQLCollatedExpression) -> any SQLExpression
}
extension Swift.ClosedRange where Bound : SQLExpressible {
  public func contains(_ element: any SQLSpecificExpressible) -> any SQLExpression
  public func contains(_ element: SQLCollatedExpression) -> any SQLExpression
}
extension Swift.CountableRange where Bound : SQLExpressible, Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public func contains(_ element: any SQLSpecificExpressible) -> any SQLExpression
}
extension Swift.CountableClosedRange where Bound : SQLExpressible, Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public func contains(_ element: any SQLSpecificExpressible) -> any SQLExpression
}
extension Swift.Sequence where Self.Element : SQLExpressible {
  public func contains(_ element: any SQLSpecificExpressible) -> any SQLExpression
  public func contains(_ element: SQLCollatedExpression) -> any SQLExpression
}
extension SQLAssociativeBinaryOperator {
  public static let add: SQLAssociativeBinaryOperator
  public static let multiply: SQLAssociativeBinaryOperator
}
public func * (lhs: any SQLSpecificExpressible, rhs: any SQLExpressible) -> any SQLExpression
public func * (lhs: any SQLExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func * (lhs: any SQLSpecificExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func / (lhs: any SQLSpecificExpressible, rhs: any SQLExpressible) -> any SQLExpression
public func / (lhs: any SQLExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func / (lhs: any SQLSpecificExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func + (lhs: any SQLSpecificExpressible, rhs: any SQLExpressible) -> any SQLExpression
public func + (lhs: any SQLExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func + (lhs: any SQLSpecificExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
prefix public func - (value: any SQLSpecificExpressible) -> any SQLExpression
public func - (lhs: any SQLSpecificExpressible, rhs: any SQLExpressible) -> any SQLExpression
public func - (lhs: any SQLExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func - (lhs: any SQLSpecificExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
extension SQLAssociativeBinaryOperator {
  public static let and: SQLAssociativeBinaryOperator
  public static let or: SQLAssociativeBinaryOperator
}
public func && (lhs: any SQLSpecificExpressible, rhs: any SQLExpressible) -> any SQLExpression
public func && (lhs: any SQLExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func && (lhs: any SQLSpecificExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func || (lhs: any SQLSpecificExpressible, rhs: any SQLExpressible) -> any SQLExpression
public func || (lhs: any SQLExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
public func || (lhs: any SQLSpecificExpressible, rhs: any SQLSpecificExpressible) -> any SQLExpression
prefix public func ! (value: any SQLSpecificExpressible) -> any SQLExpression
extension SQLSpecificExpressible {
  public func like(_ pattern: any SQLExpressible) -> any SQLExpression
}
extension SQLAssociativeBinaryOperator {
  public static let concat: SQLAssociativeBinaryOperator
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor @preconcurrency public static let modelName: Swift.String
}
public struct ATOMSwipeDataPoint {
}
extension Foundation.NSNull : DatabaseValueConvertible {
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Self?
}
public protocol SQLExpressible {
  var sqlExpression: any SQLExpression { get }
}
public protocol SQLSpecificExpressible : SQLExpressible {
}
extension SQLExpressible where Self : SQLOrderingTerm {
  public var reversed: any SQLOrderingTerm {
    get
  }
  public func orderingTermSQL(_ context: inout SQLGenerationContext) -> Swift.String
}
extension SQLExpressible where Self : SQLSelectable {
  public func resultColumnSQL(_ context: inout SQLGenerationContext) -> Swift.String
  public func countedSQL(_ context: inout SQLGenerationContext) -> Swift.String
  public func count(distinct: Swift.Bool) -> SQLCount?
  public func columnCount(_ db: Database) throws -> Swift.Int
}
extension SQLFunctionName {
  public static let abs: SQLFunctionName
}
public func abs(_ value: any SQLSpecificExpressible) -> any SQLExpression
extension SQLFunctionName {
  public static let avg: SQLFunctionName
}
public func average(_ value: any SQLSpecificExpressible) -> any SQLExpression
public func count(_ counted: any SQLSelectable) -> any SQLExpression
public func count(distinct value: any SQLSpecificExpressible) -> any SQLExpression
extension SQLFunctionName {
  public static let ifNull: SQLFunctionName
}
public func ?? (lhs: any SQLSpecificExpressible, rhs: any SQLExpressible) -> any SQLExpression
extension SQLFunctionName {
  public static let length: SQLFunctionName
}
public func length(_ value: any SQLSpecificExpressible) -> any SQLExpression
extension SQLFunctionName {
  public static let max: SQLFunctionName
}
public func max(_ value: any SQLSpecificExpressible) -> any SQLExpression
extension SQLFunctionName {
  public static let min: SQLFunctionName
}
public func min(_ value: any SQLSpecificExpressible) -> any SQLExpression
extension SQLFunctionName {
  public static let sum: SQLFunctionName
}
public func sum(_ value: any SQLSpecificExpressible) -> any SQLExpression
extension Cursor {
  @available(*, unavailable, renamed: "compactMap")
  public func flatMap<ElementOfResult>(_ transform: @escaping (Self.Element) throws -> ElementOfResult?) -> MapCursor<FilterCursor<MapCursor<Self, ElementOfResult?>>, ElementOfResult>
}
extension DatabaseWriter {
  @available(*, unavailable, message: "Use concurrentRead instead")
  public func readFromCurrentState(_ block: @escaping (Database) -> Swift.Void) throws
}
@available(*, unavailable, renamed: "FastDatabaseValueCursor")
public typealias ColumnCursor<Value> = FastDatabaseValueCursor<Value> where Value : DatabaseValueConvertible, Value : StatementColumnConvertible
@available(*, unavailable, renamed: "FastNullableDatabaseValueCursor")
public typealias NullableColumnCursor<Value> = FastNullableDatabaseValueCursor<Value> where Value : DatabaseValueConvertible, Value : StatementColumnConvertible
extension Database {
  @available(*, unavailable, renamed: "execute(sql:arguments:)")
  final public func execute(_ sql: Swift.String, arguments: StatementArguments? = nil) throws
  @available(*, unavailable, renamed: "makeSelectStatement(sql:)")
  final public func makeSelectStatement(_ sql: Swift.String) throws -> SelectStatement
  @available(*, unavailable, renamed: "cachedSelectStatement(sql:)")
  final public func cachedSelectStatement(_ sql: Swift.String) throws -> SelectStatement
  @available(*, unavailable, renamed: "makeUpdateStatement(sql:)")
  final public func makeUpdateStatement(_ sql: Swift.String) throws -> UpdateStatement
  @available(*, unavailable, renamed: "cachedUpdateStatement(sql:)")
  final public func cachedUpdateStatement(_ sql: Swift.String) throws -> UpdateStatement
}
extension DatabaseValueConvertible {
  @available(*, unavailable, renamed: "fetchCursor(_:sql:arguments:adapter:)")
  public static func fetchCursor(_ db: Database, _ sql: Swift.String, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> DatabaseValueCursor<Self>
  @available(*, unavailable, renamed: "fetchAll(_:sql:arguments:adapter:)")
  public static func fetchAll(_ db: Database, _ sql: Swift.String, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> [Self]
  @available(*, unavailable, renamed: "fetchOne(_:sql:arguments:adapter:)")
  public static func fetchOne(_ db: Database, _ sql: Swift.String, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> Self?
}
extension Swift.Optional where Wrapped : DatabaseValueConvertible {
  @available(*, unavailable, renamed: "fetchCursor(_:sql:arguments:adapter:)")
  public static func fetchCursor(_ db: Database, _ sql: Swift.String, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> NullableDatabaseValueCursor<Wrapped>
  @available(*, unavailable, renamed: "fetchAll(_:sql:arguments:adapter:)")
  public static func fetchAll(_ db: Database, _ sql: Swift.String, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> [Wrapped?]
}
extension Row {
  @available(*, unavailable, renamed: "fetchCursor(_:sql:arguments:adapter:)")
  public static func fetchCursor(_ db: Database, _ sql: Swift.String, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> RowCursor
  @available(*, unavailable, renamed: "fetchAll(_:sql:arguments:adapter:)")
  public static func fetchAll(_ db: Database, _ sql: Swift.String, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> [Row]
  @available(*, unavailable, renamed: "fetchOne(_:sql:arguments:adapter:)")
  public static func fetchOne(_ db: Database, _ sql: Swift.String, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> Row?
}
extension DatabaseValueConvertible where Self : StatementColumnConvertible {
  @available(*, unavailable, renamed: "fetchCursor(_:sql:arguments:adapter:)")
  public static func fetchCursor(_ db: Database, _ sql: Swift.String, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> FastDatabaseValueCursor<Self>
}
extension Swift.Optional where Wrapped : DatabaseValueConvertible, Wrapped : StatementColumnConvertible {
  @available(*, unavailable, renamed: "fetchCursor(_:sql:arguments:adapter:)")
  public static func fetchCursor(_ db: Database, _ sql: Swift.String, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> FastNullableDatabaseValueCursor<Wrapped>
}
extension FetchableRecord {
  @available(*, unavailable, renamed: "fetchCursor(_:sql:arguments:adapter:)")
  public static func fetchCursor(_ db: Database, _ sql: Swift.String, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> RecordCursor<Self>
  @available(*, unavailable, renamed: "fetchAll(_:sql:arguments:adapter:)")
  public static func fetchAll(_ db: Database, _ sql: Swift.String, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> [Self]
  @available(*, unavailable, renamed: "fetchOne(_:sql:arguments:adapter:)")
  public static func fetchOne(_ db: Database, _ sql: Swift.String, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> Self?
}
extension SQLRequest {
  @available(*, unavailable, renamed: "init(sql:arguments:adapter:cached:)")
  public init(_ sql: Swift.String, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil, cached: Swift.Bool = false)
}
extension SQLExpressionLiteral {
  @available(*, unavailable, renamed: "init(sql:arguments:)")
  public init(_ sql: Swift.String, arguments: StatementArguments? = nil)
}
extension SQLExpression {
  @available(*, unavailable, message: "Use sqlLiteral property instead")
  public var literal: SQLExpressionLiteral {
    get
  }
}
extension DatabaseValue {
  @available(*, unavailable)
  public func losslessConvert<T>(sql: Swift.String? = nil, arguments: StatementArguments? = nil) -> T where T : DatabaseValueConvertible
  @available(*, unavailable)
  public func losslessConvert<T>(sql: Swift.String? = nil, arguments: StatementArguments? = nil) -> T? where T : DatabaseValueConvertible
}
extension Configuration {
  @available(*, unavailable, message: "Run the PRAGMA cipher_page_size in Configuration.prepareDatabase instead.")
  public var cipherPageSize: Swift.Int {
    get
    set
  }
  @available(*, unavailable, message: "Run the PRAGMA kdf_iter in Configuration.prepareDatabase instead.")
  public var kdfIterations: Swift.Int {
    get
    set
  }
}
@_hasMissingDesignatedInitializers @objc final public class ATOMEvent : ObjectiveC.NSObject {
  @objc deinit
}
extension ATOMEvent {
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
}
extension ATOMEvent {
  final public func name() -> Swift.String
  final public func value() -> Any?
  final public func timestamp() -> Swift.Int
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency final public class ATOMTouchView : UIKit.UIImageView {
  @_Concurrency.MainActor @preconcurrency final public var config: ATOMTouchConfiguration {
    get
    set(value)
  }
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
extension Inflections {
  public static var `default`: Inflections
}
public struct SQLRequest<T> : FetchRequest {
  public typealias RowDecoder = T
  public var sql: Swift.String {
    get
  }
  public var arguments: StatementArguments {
    get
  }
  public var adapter: (any RowAdapter)?
  public init(sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil, cached: Swift.Bool = false)
  public init(literal sqlLiteral: SQLLiteral, adapter: (any RowAdapter)? = nil, cached: Swift.Bool = false)
  public init<Request>(_ db: Database, request: Request, cached: Swift.Bool = false) throws where T == Request.RowDecoder, Request : FetchRequest
  public func makePreparedRequest(_ db: Database, forSingleResult singleResult: Swift.Bool) throws -> PreparedRequest
}
extension SQLRequest : Swift.ExpressibleByStringInterpolation {
  public init(unicodeScalarLiteral: Swift.String)
  public init(extendedGraphemeClusterLiteral: Swift.String)
  public init(stringLiteral: Swift.String)
  public init(stringInterpolation sqlInterpolation: SQLInterpolation)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringInterpolation = SQLInterpolation
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension DatabaseValueConvertible where Self : Swift.Decodable {
  public static func fromDatabaseValue(_ databaseValue: DatabaseValue) -> Self?
}
extension DatabaseValueConvertible where Self : Swift.Decodable, Self : Swift.RawRepresentable, Self.RawValue : DatabaseValueConvertible {
  public static func fromDatabaseValue(_ databaseValue: DatabaseValue) -> Self?
}
public struct ATOMPinchDataPoint {
}
@_hasMissingDesignatedInitializers public class ATOMSignalManager {
  @objc deinit
}
public enum ATOMCellularConnectionType {
  case noConnection
  case unknown
  case g2
  case g3
  case g4
  case g5
  public static func == (a: ATOMCellularConnectionType, b: ATOMCellularConnectionType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ATOMReachabilityManagerProtocol : AnyObject {
  var currentCellularConnectionType: ATOMCellularConnectionType { get }
  var connectionStatus: ATOMReachability.Connection { get }
}
public struct ATOMArchiveSettings : Swift.Codable {
  public var shouldArchive: Swift.Bool? {
    get
  }
  public var samplingRate: Swift.Double? {
    get
  }
  public var uploadFrequency: ATOMArchiveUploadFrequency? {
    get
  }
  public var tableNamesToExport: [Swift.String]? {
    get
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ATOMArchiveUploadFrequency : Swift.Codable {
  public var days: Swift.String? {
    get
  }
  public var startupCount: Swift.String? {
    get
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ATOMZip {
  public class func quickZipFiles(_ paths: [Foundation.URL], fileName: Swift.String) throws -> Foundation.URL
  public class func quickZipFiles(_ paths: [Foundation.URL], fileName: Swift.String, progress: ((_ progress: Swift.Double) -> ())?) throws -> Foundation.URL
}
public enum ZipError : Swift.Error {
  case fileNotFound
  case unzipFail
  case zipFail
  public var description: Swift.String {
    get
  }
  public static func == (a: ZipError, b: ZipError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ZipCompression : Swift.Int {
  case NoCompression
  case BestSpeed
  case DefaultCompression
  case BestCompression
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct ArchiveFile {
  public init(filename: Swift.String, data: Foundation.NSData, modifiedTime: Foundation.Date?)
}
public class ATOMZip {
  public init()
  public class func zipFiles(paths: [Foundation.URL], zipFilePath: Foundation.URL, password: Swift.String?, compression: ZipCompression = .DefaultCompression, progress: ((_ progress: Swift.Double) -> ())?) throws
  public class func zipData(archiveFiles: [ArchiveFile], zipFilePath: Foundation.URL, password: Swift.String?, compression: ZipCompression = .DefaultCompression, progress: ((_ progress: Swift.Double) -> ())?) throws
  public class func addCustomFileExtension(_ fileExtension: Swift.String)
  public class func removeCustomFileExtension(_ fileExtension: Swift.String)
  public class func isValidFileExtension(_ fileExtension: Swift.String) -> Swift.Bool
  @objc deinit
}
extension Foundation.Date {
  public var reportableString: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class ATOMSynchronizedArray<T> {
  public func append(newElement: T)
  public func appendIfNotExists(_ newElement: T) where T : Swift.Equatable
  public func removeAtIndex(index: Swift.Int)
  public func removeFirstOccurrence(of element: T) where T : Swift.Equatable
  public var count: Swift.Int {
    get
  }
  public func first() -> T?
  public subscript(index: Swift.Int) -> T? {
    get
    set
  }
  public func safeElement(at index: Swift.Int) -> T?
  public func firstIndex(of element: T) -> Swift.Int? where T : Swift.Equatable
  public func takeSnapshotAndRemoveAll() -> [T]
  public func updateElement(where predicate: @escaping (T) -> Swift.Bool, update: @escaping (inout T) -> Swift.Void)
  public func makeSnapshot() -> [T]
  @objc deinit
}
extension ATOMSynchronizedArray : Swift.Sequence {
  public func makeIterator() -> Swift.Array<T>.Iterator
  public typealias Element = Swift.IndexingIterator<Swift.Array<T>>.Element
  public typealias Iterator = Swift.Array<T>.Iterator
}
public struct QueryInterfaceRequest<T> {
}
extension QueryInterfaceRequest : FetchRequest {
  public typealias RowDecoder = T
  public func makePreparedRequest(_ db: Database, forSingleResult singleResult: Swift.Bool) throws -> PreparedRequest
  public func fetchCount(_ db: Database) throws -> Swift.Int
  public func databaseRegion(_ db: Database) throws -> DatabaseRegion
}
extension QueryInterfaceRequest : SelectionRequest {
  public func select(_ selection: [any SQLSelectable]) -> QueryInterfaceRequest<T>
  public func select<RowDecoder>(_ selection: [any SQLSelectable], as type: RowDecoder.Type = RowDecoder.self) -> QueryInterfaceRequest<RowDecoder>
  public func select<RowDecoder>(_ selection: any SQLSelectable..., as type: RowDecoder.Type = RowDecoder.self) -> QueryInterfaceRequest<RowDecoder>
  public func select<RowDecoder>(sql: Swift.String, arguments: StatementArguments = StatementArguments(), as type: RowDecoder.Type = RowDecoder.self) -> QueryInterfaceRequest<RowDecoder>
  public func select<RowDecoder>(literal sqlLiteral: SQLLiteral, as type: RowDecoder.Type = RowDecoder.self) -> QueryInterfaceRequest<RowDecoder>
  public func annotated(with selection: [any SQLSelectable]) -> QueryInterfaceRequest<T>
}
extension QueryInterfaceRequest : FilteredRequest {
  public func filter(_ predicate: @escaping (Database) throws -> any SQLExpressible) -> QueryInterfaceRequest<T>
}
extension QueryInterfaceRequest : OrderedRequest {
  public func order(_ orderings: @escaping (Database) throws -> [any SQLOrderingTerm]) -> QueryInterfaceRequest<T>
  public func reversed() -> QueryInterfaceRequest<T>
  public func unordered() -> QueryInterfaceRequest<T>
}
extension QueryInterfaceRequest : AggregatingRequest {
  public func group(_ expressions: @escaping (Database) throws -> [any SQLExpressible]) -> QueryInterfaceRequest<T>
  public func having(_ predicate: any SQLExpressible) -> QueryInterfaceRequest<T>
}
extension QueryInterfaceRequest : _JoinableRequest {
  public func _including(all association: SQLAssociation) -> QueryInterfaceRequest<T>
  public func _including(optional association: SQLAssociation) -> QueryInterfaceRequest<T>
  public func _including(required association: SQLAssociation) -> QueryInterfaceRequest<T>
  public func _joining(optional association: SQLAssociation) -> QueryInterfaceRequest<T>
  public func _joining(required association: SQLAssociation) -> QueryInterfaceRequest<T>
}
extension QueryInterfaceRequest : JoinableRequest where T : TableRecord {
}
extension QueryInterfaceRequest {
  public func distinct() -> QueryInterfaceRequest<T>
  public func expectingSingleResult() -> QueryInterfaceRequest<T>
  public func limit(_ limit: Swift.Int, offset: Swift.Int? = nil) -> QueryInterfaceRequest<T>
  public func aliased(_ alias: TableAlias) -> QueryInterfaceRequest<T>
  public func asRequest<RowDecoder>(of type: RowDecoder.Type) -> QueryInterfaceRequest<RowDecoder>
}
extension QueryInterfaceRequest : TableRequest {
  public var databaseTableName: Swift.String {
    get
  }
}
extension QueryInterfaceRequest : DerivableRequest where T : TableRecord {
}
extension QueryInterfaceRequest where T : MutablePersistableRecord {
  @discardableResult
  public func deleteAll(_ db: Database) throws -> Swift.Int
  @discardableResult
  public func updateAll(_ db: Database, onConflict conflictResolution: Database.ConflictResolution? = nil, _ assignments: [ColumnAssignment]) throws -> Swift.Int
  @discardableResult
  public func updateAll(_ db: Database, onConflict conflictResolution: Database.ConflictResolution? = nil, _ assignment: ColumnAssignment, _ otherAssignments: ColumnAssignment...) throws -> Swift.Int
}
public struct ColumnAssignment {
}
precedencegroup ColumnAssignment {
  associativity: left
  assignment: true
  lowerThan: AssignmentPrecedence
}
infix operator <- : ColumnAssignment
@available(*, deprecated, message: "Use column.set(to: value) instead")
public func <- (column: any ColumnExpression, value: (any SQLExpressible)?) -> ColumnAssignment
extension ColumnExpression {
  public func set(to value: (any SQLExpressible)?) -> ColumnAssignment
}
public func += (column: any ColumnExpression, value: any SQLExpressible) -> ColumnAssignment
public func -= (column: any ColumnExpression, value: any SQLExpressible) -> ColumnAssignment
public func *= (column: any ColumnExpression, value: any SQLExpressible) -> ColumnAssignment
public func /= (column: any ColumnExpression, value: any SQLExpressible) -> ColumnAssignment
extension Database {
  final public func clearSchemaCache()
  final public func tableExists(_ name: Swift.String) throws -> Swift.Bool
  final public func isSQLiteInternalTable(_ tableName: Swift.String) -> Swift.Bool
  final public func isGRDBInternalTable(_ tableName: Swift.String) -> Swift.Bool
  final public func viewExists(_ name: Swift.String) throws -> Swift.Bool
  final public func triggerExists(_ name: Swift.String) throws -> Swift.Bool
  final public func primaryKey(_ tableName: Swift.String) throws -> PrimaryKeyInfo
  final public func indexes(on tableName: Swift.String) throws -> [IndexInfo]
  final public func table<T>(_ tableName: Swift.String, hasUniqueKey columns: T) throws -> Swift.Bool where T : Swift.Sequence, T.Element == Swift.String
  final public func foreignKeys(on tableName: Swift.String) throws -> [ForeignKeyInfo]
}
extension Database {
  final public func columns(in tableName: Swift.String) throws -> [ColumnInfo]
}
public struct ColumnInfo : FetchableRecord {
  public let name: Swift.String
  public let type: Swift.String
  public let isNotNull: Swift.Bool
  public let defaultValueSQL: Swift.String?
  public let primaryKeyIndex: Swift.Int
  public init(row: Row)
}
public struct IndexInfo {
  public let name: Swift.String
  public let columns: [Swift.String]
  public let isUnique: Swift.Bool
}
public struct PrimaryKeyInfo {
  public var columns: [Swift.String] {
    get
  }
  public var rowIDColumn: Swift.String? {
    get
  }
  public var isRowID: Swift.Bool {
    get
  }
}
public struct ForeignKeyInfo {
  public let destinationTable: Swift.String
  public let mapping: [(origin: Swift.String, destination: Swift.String)]
  public var originColumns: [Swift.String] {
    get
  }
  public var destinationColumns: [Swift.String] {
    get
  }
}
@_hasMissingDesignatedInitializers final public class FetchedRecordsController<Record> where Record : FetchableRecord {
  convenience public init(_ databaseWriter: any DatabaseWriter, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil, queue: Dispatch.DispatchQueue = .main, isSameRecord: ((Record, Record) -> Swift.Bool)? = nil) throws
  convenience public init<Request>(_ databaseWriter: any DatabaseWriter, request: Request, queue: Dispatch.DispatchQueue = .main, isSameRecord: ((Record, Record) -> Swift.Bool)? = nil) throws where Record == Request.RowDecoder, Request : FetchRequest
  final public func performFetch() throws
  final public let databaseWriter: any DatabaseWriter
  final public let queue: Dispatch.DispatchQueue
  final public func setRequest<Request>(_ request: Request) throws where Record == Request.RowDecoder, Request : FetchRequest
  final public func setRequest(sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil) throws
  final public func trackChanges(willChange: ((FetchedRecordsController<Record>) -> Swift.Void)? = nil, onChange: ((FetchedRecordsController<Record>, Record, FetchedRecordChange) -> Swift.Void)? = nil, didChange: ((FetchedRecordsController<Record>) -> Swift.Void)? = nil)
  final public func trackChanges<T>(fetchAlongside: @escaping (Database) throws -> T, willChange: ((FetchedRecordsController<Record>, _ fetchedAlongside: T) -> Swift.Void)? = nil, onChange: ((FetchedRecordsController<Record>, Record, FetchedRecordChange) -> Swift.Void)? = nil, didChange: ((FetchedRecordsController<Record>, _ fetchedAlongside: T) -> Swift.Void)? = nil)
  final public func trackErrors(_ errorHandler: @escaping (FetchedRecordsController<Record>, any Swift.Error) -> Swift.Void)
  final public func allowBackgroundChangesTracking(in application: UIKit.UIApplication)
  final public var fetchedRecords: [Record] {
    get
  }
  @objc deinit
}
extension FetchedRecordsController where Record : TableRecord {
  convenience public init(_ databaseWriter: any DatabaseWriter, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil, queue: Dispatch.DispatchQueue = .main) throws
  convenience public init<Request>(_ databaseWriter: any DatabaseWriter, request: Request, queue: Dispatch.DispatchQueue = .main) throws where Record == Request.RowDecoder, Request : FetchRequest
}
extension FetchedRecordsController {
  final public func record(at indexPath: Foundation.IndexPath) -> Record
  final public var sections: [FetchedRecordsSectionInfo<Record>] {
    get
  }
}
extension FetchedRecordsController where Record : EncodableRecord {
  final public func indexPath(for record: Record) -> Foundation.IndexPath?
}
public enum FetchedRecordChange {
  case insertion(indexPath: Foundation.IndexPath)
  case deletion(indexPath: Foundation.IndexPath)
  case move(indexPath: Foundation.IndexPath, newIndexPath: Foundation.IndexPath, changes: [Swift.String : DatabaseValue])
  case update(indexPath: Foundation.IndexPath, changes: [Swift.String : DatabaseValue])
}
extension FetchedRecordChange : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct FetchedRecordsSectionInfo<Record> where Record : FetchableRecord {
  public var numberOfRecords: Swift.Int {
    get
  }
  public var records: [Record] {
    get
  }
}
public struct SQLLiteral {
  public var sql: Swift.String {
    get
  }
  public var arguments: StatementArguments {
    get
  }
  public init(sql: Swift.String, arguments: StatementArguments = StatementArguments())
  public init(_ expression: any SQLExpression)
  public func mapSQL(_ transform: @escaping (Swift.String) -> Swift.String) -> SQLLiteral
}
extension SQLLiteral {
  public static func + (lhs: SQLLiteral, rhs: SQLLiteral) -> SQLLiteral
  public static func += (lhs: inout SQLLiteral, rhs: SQLLiteral)
  public mutating func append(literal sqlLiteral: SQLLiteral)
  public mutating func append(sql: Swift.String, arguments: StatementArguments = StatementArguments())
}
extension SQLLiteral {
  public var sqlExpression: any SQLExpression {
    get
  }
}
extension Swift.Sequence where Self.Element == SQLLiteral {
  public func joined(separator: Swift.String = "") -> SQLLiteral
}
extension Swift.Collection where Self.Element == SQLLiteral {
  public func joined(separator: Swift.String = "") -> SQLLiteral
}
extension SQLLiteral : Swift.ExpressibleByStringInterpolation {
  public init(unicodeScalarLiteral: Swift.String)
  public init(extendedGraphemeClusterLiteral: Swift.String)
  public init(stringLiteral: Swift.String)
  public init(stringInterpolation sqlInterpolation: SQLInterpolation)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringInterpolation = SQLInterpolation
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public struct SQLExpressionLiteral : SQLExpression {
  public var sql: Swift.String {
    get
  }
  public var arguments: StatementArguments {
    get
  }
  @available(*, deprecated, message: "Use SQLiteral.sqlExpression instead")
  public init(sql: Swift.String, arguments: StatementArguments = StatementArguments())
  @available(*, deprecated, message: "Use SQLiteral.sqlExpression instead")
  public init(literal sqlLiteral: SQLLiteral)
  public func expressionSQL(_ context: inout SQLGenerationContext, wrappedInParenthesis: Swift.Bool) -> Swift.String
  public func qualifiedExpression(with alias: TableAlias) -> any SQLExpression
}
public struct SQLInterpolation : Swift.StringInterpolationProtocol {
  public init(literalCapacity: Swift.Int, interpolationCount: Swift.Int)
  public mutating func appendLiteral(_ sql: Swift.String)
  public mutating func appendInterpolation(sql: Swift.String, arguments: StatementArguments = StatementArguments())
  public mutating func appendInterpolation(literal sqlLiteral: SQLLiteral)
  public typealias StringLiteralType = Swift.String
}
extension Swift.Int {
  public static var timestamp: Swift.Int {
    get
  }
}
public protocol TableRecord {
  static var databaseTableName: Swift.String { get }
  static var databaseSelection: [any SQLSelectable] { get }
}
extension TableRecord {
  public static var databaseTableName: Swift.String {
    get
  }
  public static var databaseSelection: [any SQLSelectable] {
    get
  }
}
extension TableRecord {
  public static func fetchCount(_ db: Database) throws -> Swift.Int
}
extension TableRecord {
  public static func selectionSQL(alias: Swift.String? = nil) -> Swift.String
  public static func numberOfSelectedColumns(_ db: Database) throws -> Swift.Int
}
public protocol SQLSelectable {
  func resultColumnSQL(_ context: inout SQLGenerationContext) -> Swift.String
  func countedSQL(_ context: inout SQLGenerationContext) -> Swift.String
  func count(distinct: Swift.Bool) -> SQLCount?
  func columnCount(_ db: Database) throws -> Swift.Int
  func qualifiedSelectable(with alias: TableAlias) -> any SQLSelectable
}
public enum SQLCount {
  case all
  case distinct(any SQLExpression)
}
extension DatabaseValueConvertible where Self : Foundation.ReferenceConvertible, Self.ReferenceType : DatabaseValueConvertible {
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Self?
}
extension DatabaseValueConvertible where Self : Foundation.ReferenceConvertible, Self : Swift.Decodable, Self.ReferenceType : DatabaseValueConvertible {
  public static func fromDatabaseValue(_ databaseValue: DatabaseValue) -> Self?
}
extension DatabaseValueConvertible where Self : Foundation.ReferenceConvertible, Self : Swift.Encodable, Self.ReferenceType : DatabaseValueConvertible {
  public var databaseValue: DatabaseValue {
    get
  }
}
extension Swift.String {
  @inlinable public var quotedDatabaseIdentifier: Swift.String {
    get {
         
        return "\"\(self)\""
    }
  }
}
@inlinable public func databaseQuestionMarks(count: Swift.Int) -> Swift.String {
    return repeatElement("?", count: count).joined(separator: ",")
}
public protocol _OptionalProtocol {
  associatedtype _Wrapped
}
extension Swift.Optional : _OptionalProtocol {
  public typealias _Wrapped = Wrapped
}
@inlinable internal func GRDBPrecondition(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = "", file: Swift.StaticString = #file, line: Swift.UInt = #line) {
     
     
     
}
extension Swift.Sequence {
  @inlinable internal func count(where predicate: (Self.Element) throws -> Swift.Bool) rethrows -> Swift.Int {
        var count = 0
        for e in self where try predicate(e) {
            count += 1
        }
        return count
    }
}
public protocol FetchableRecord {
  init(row: Row)
  static var databaseDecodingUserInfo: [Swift.CodingUserInfoKey : Any] { get }
  static func databaseJSONDecoder(for column: Swift.String) -> Foundation.JSONDecoder
  static var databaseDateDecodingStrategy: DatabaseDateDecodingStrategy { get }
}
extension FetchableRecord {
  public static var databaseDecodingUserInfo: [Swift.CodingUserInfoKey : Any] {
    get
  }
  public static func databaseJSONDecoder(for column: Swift.String) -> Foundation.JSONDecoder
  public static var databaseDateDecodingStrategy: DatabaseDateDecodingStrategy {
    get
  }
}
extension FetchableRecord {
  public static func fetchCursor(_ statement: SelectStatement, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> RecordCursor<Self>
  public static func fetchAll(_ statement: SelectStatement, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> [Self]
  public static func fetchOne(_ statement: SelectStatement, arguments: StatementArguments? = nil, adapter: (any RowAdapter)? = nil) throws -> Self?
}
extension FetchableRecord {
  public static func fetchCursor(_ db: Database, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil) throws -> RecordCursor<Self>
  public static func fetchAll(_ db: Database, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil) throws -> [Self]
  public static func fetchOne(_ db: Database, sql: Swift.String, arguments: StatementArguments = StatementArguments(), adapter: (any RowAdapter)? = nil) throws -> Self?
}
extension FetchableRecord {
  public static func fetchCursor<R>(_ db: Database, _ request: R) throws -> RecordCursor<Self> where R : FetchRequest
  public static func fetchAll<R>(_ db: Database, _ request: R) throws -> [Self] where R : FetchRequest
  public static func fetchOne<R>(_ db: Database, _ request: R) throws -> Self? where R : FetchRequest
}
extension FetchRequest where Self.RowDecoder : FetchableRecord {
  public func fetchCursor(_ db: Database) throws -> RecordCursor<Self.RowDecoder>
  public func fetchAll(_ db: Database) throws -> [Self.RowDecoder]
  public func fetchOne(_ db: Database) throws -> Self.RowDecoder?
}
@_hasMissingDesignatedInitializers final public class RecordCursor<Record> : Cursor where Record : FetchableRecord {
  @usableFromInline
  final internal let _statement: SelectStatement
  @usableFromInline
  final internal let _row: Row
  @usableFromInline
  final internal let _sqliteStatement: SQLiteStatement
  @usableFromInline
  final internal var _done: Swift.Bool
  @objc deinit
  @inlinable final public func next() throws -> Record? {
        if _done {
             
             
            return nil
        }
        switch sqlite3_step(_sqliteStatement) {
        case SQLITE_DONE:
            _done = true
            return nil
        case SQLITE_ROW:
            return Record(row: _row)
        case let code:
            try _statement.didFail(withResultCode: code)
        }
    }
  public typealias Element = Record
}
public enum DatabaseDateDecodingStrategy {
  case deferredToDate
  case timeIntervalSinceReferenceDate
  case timeIntervalSince1970
  case millisecondsSince1970
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  case iso8601
  case formatted(Foundation.DateFormatter)
  case custom((DatabaseValue) -> Foundation.Date?)
}
public struct DatabaseRegionObservation {
  public var extent: Database.TransactionObservationExtent
}
extension DatabaseRegionObservation {
  public init(tracking regions: any DatabaseRegionConvertible...)
  public init(tracking regions: [any DatabaseRegionConvertible])
}
extension DatabaseRegionObservation {
  public func start(in dbWriter: any DatabaseWriter, onChange: @escaping (Database) -> Swift.Void) throws -> any TransactionObserver
}
public protocol SQLOrderingTerm {
  var reversed: any SQLOrderingTerm { get }
  func orderingTermSQL(_ context: inout SQLGenerationContext) -> Swift.String
  func qualifiedOrdering(with alias: TableAlias) -> any SQLOrderingTerm
}
@objc public class ATOMAdParameters : ObjectiveC.NSObject, Swift.Encodable {
  @objc public init(creativeID: Swift.String, cohorts: [Swift.String], impressionURLs: [Swift.String], clickURL: [Swift.String])
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Database.ConflictResolution {
  @usableFromInline
  internal var invalidatesLastInsertedRowID: Swift.Bool {
    get
  }
}
public enum PersistenceError : Swift.Error, Swift.CustomStringConvertible {
  case recordNotFound(databaseTableName: Swift.String, key: [Swift.String : DatabaseValue])
}
extension PersistenceError {
  public var description: Swift.String {
    get
  }
}
public struct PersistenceConflictPolicy {
  public let conflictResolutionForInsert: Database.ConflictResolution
  public let conflictResolutionForUpdate: Database.ConflictResolution
  public init(insert: Database.ConflictResolution = .abort, update: Database.ConflictResolution = .abort)
}
public protocol MutablePersistableRecord : EncodableRecord, TableRecord {
  static var persistenceConflictPolicy: PersistenceConflictPolicy { get }
  mutating func didInsert(with rowID: Swift.Int64, for column: Swift.String?)
  mutating func insert(_ db: Database) throws
  func update(_ db: Database, columns: Swift.Set<Swift.String>) throws
  mutating func save(_ db: Database) throws
  @discardableResult
  func delete(_ db: Database) throws -> Swift.Bool
  func exists(_ db: Database) throws -> Swift.Bool
}
extension MutablePersistableRecord {
  public static var persistenceConflictPolicy: PersistenceConflictPolicy {
    get
  }
  public mutating func didInsert(with rowID: Swift.Int64, for column: Swift.String?)
  public mutating func insert(_ db: Database) throws
  public func update(_ db: Database, columns: Swift.Set<Swift.String>) throws
  public func update<Sequence>(_ db: Database, columns: Sequence) throws where Sequence : Swift.Sequence, Sequence.Element : ColumnExpression
  public func update<Sequence>(_ db: Database, columns: Sequence) throws where Sequence : Swift.Sequence, Sequence.Element == Swift.String
  public func update(_ db: Database) throws
  @discardableResult
  public func updateChanges<Record>(_ db: Database, from record: Record) throws -> Swift.Bool where Record : MutablePersistableRecord
  @discardableResult
  public mutating func updateChanges(_ db: Database, with change: (inout Self) throws -> Swift.Void) throws -> Swift.Bool
  public mutating func save(_ db: Database) throws
  @discardableResult
  public func delete(_ db: Database) throws -> Swift.Bool
  public func exists(_ db: Database) throws -> Swift.Bool
  @usableFromInline
  internal func primaryKey(_ db: Database) throws -> [Swift.String : DatabaseValue]?
  @inlinable public mutating func performInsert(_ db: Database) throws {
        let conflictResolutionForInsert = type(of: self).persistenceConflictPolicy.conflictResolutionForInsert
        let dao = try DAO(db, self)
        try dao.insertStatement(onConflict: conflictResolutionForInsert).execute()
        
        if !conflictResolutionForInsert.invalidatesLastInsertedRowID {
            didInsert(with: db.lastInsertedRowID, for: dao.primaryKey.rowIDColumn)
        }
    }
  @inlinable public func performUpdate(_ db: Database, columns: Swift.Set<Swift.String>) throws {
        let dao = try DAO(db, self)
        guard
            let statement = try dao.updateStatement(
                columns: columns,
                onConflict: type(of: self).persistenceConflictPolicy.conflictResolutionForUpdate)
            else {
                 
                throw dao.makeRecordNotFoundError()
        }
        try statement.execute()
        if db.changesCount == 0 {
            throw dao.makeRecordNotFoundError()
        }
    }
  @inlinable public mutating func performSave(_ db: Database) throws {
         
         
        if let key = try primaryKey(db) {
            do {
                try update(db)
            } catch PersistenceError.recordNotFound(databaseTableName: type(of: self).databaseTableName, key: key) {
                try insert(db)
            }
        } else {
            try insert(db)
        }
    }
  @inlinable public func performDelete(_ db: Database) throws -> Swift.Bool {
        guard let statement = try DAO(db, self).deleteStatement() else {
             
            return false
        }
        try statement.execute()
        return db.changesCount > 0
    }
  @inlinable public func performExists(_ db: Database) throws -> Swift.Bool {
        guard let statement = try DAO(db, self).existsStatement() else {
             
            return false
        }
        return try Row.fetchOne(statement) != nil
    }
}
extension MutablePersistableRecord where Self : AnyObject {
  @discardableResult
  public func updateChanges(_ db: Database, with change: (Self) throws -> Swift.Void) throws -> Swift.Bool
}
extension MutablePersistableRecord {
  @discardableResult
  public static func deleteAll(_ db: Database) throws -> Swift.Int
  @discardableResult
  public static func updateAll(_ db: Database, onConflict conflictResolution: Database.ConflictResolution? = nil, _ assignments: [ColumnAssignment]) throws -> Swift.Int
  @discardableResult
  public static func updateAll(_ db: Database, onConflict conflictResolution: Database.ConflictResolution? = nil, _ assignment: ColumnAssignment, _ otherAssignments: ColumnAssignment...) throws -> Swift.Int
}
extension MutablePersistableRecord {
  @discardableResult
  public static func deleteAll<Sequence>(_ db: Database, keys: Sequence) throws -> Swift.Int where Sequence : Swift.Sequence, Sequence.Element : DatabaseValueConvertible
  @discardableResult
  public static func deleteOne<PrimaryKeyType>(_ db: Database, key: PrimaryKeyType?) throws -> Swift.Bool where PrimaryKeyType : DatabaseValueConvertible
}
extension MutablePersistableRecord {
  @discardableResult
  public static func deleteAll(_ db: Database, keys: [[Swift.String : (any DatabaseValueConvertible)?]]) throws -> Swift.Int
  @discardableResult
  public static func deleteOne(_ db: Database, key: [Swift.String : (any DatabaseValueConvertible)?]) throws -> Swift.Bool
}
public protocol PersistableRecord : MutablePersistableRecord {
  func didInsert(with rowID: Swift.Int64, for column: Swift.String?)
  func insert(_ db: Database) throws
  func save(_ db: Database) throws
}
extension PersistableRecord {
  public func didInsert(with rowID: Swift.Int64, for column: Swift.String?)
  public func insert(_ db: Database) throws
  public func save(_ db: Database) throws
  @inlinable public func performInsert(_ db: Database) throws {
        let conflictResolutionForInsert = type(of: self).persistenceConflictPolicy.conflictResolutionForInsert
        let dao = try DAO(db, self)
        try dao.insertStatement(onConflict: conflictResolutionForInsert).execute()
        
        if !conflictResolutionForInsert.invalidatesLastInsertedRowID {
            didInsert(with: db.lastInsertedRowID, for: dao.primaryKey.rowIDColumn)
        }
    }
  @inlinable public func performSave(_ db: Database) throws {
         
         
        if let key = try primaryKey(db) {
            do {
                try update(db)
            } catch PersistenceError.recordNotFound(databaseTableName: type(of: self).databaseTableName, key: key) {
                try insert(db)
            }
        } else {
            try insert(db)
        }
    }
}
@usableFromInline
final internal class DAO<Record> where Record : MutablePersistableRecord {
  @usableFromInline
  final internal let primaryKey: PrimaryKeyInfo
  @usableFromInline
  internal init(_ db: Database, _ record: Record) throws
  @usableFromInline
  final internal func insertStatement(onConflict: Database.ConflictResolution) throws -> UpdateStatement
  @usableFromInline
  final internal func updateStatement(columns: Swift.Set<Swift.String>, onConflict: Database.ConflictResolution) throws -> UpdateStatement?
  @usableFromInline
  final internal func deleteStatement() throws -> UpdateStatement?
  @usableFromInline
  final internal func existsStatement() throws -> SelectStatement?
  @usableFromInline
  final internal func makeRecordNotFoundError() -> any Swift.Error
  @objc @usableFromInline
  deinit
}
extension Foundation.NSDate : DatabaseValueConvertible {
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Self?
}
extension Foundation.Date : DatabaseValueConvertible {
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Foundation.Date?
  @usableFromInline
  internal init?(databaseDateComponents: DatabaseDateComponents)
  public init?(julianDay: Swift.Double)
}
extension Foundation.Date : StatementColumnConvertible {
  @inlinable public init(sqliteStatement: SQLiteStatement, index: Swift.Int32) {
        switch sqlite3_column_type(sqliteStatement, index) {
        case SQLITE_INTEGER, SQLITE_FLOAT:
            self.init(timeIntervalSince1970: sqlite3_column_double(sqliteStatement, index))
        case SQLITE_TEXT:
            let databaseDateComponents = DatabaseDateComponents(sqliteStatement: sqliteStatement, index: index)
            guard let date = Date(databaseDateComponents: databaseDateComponents) else {
                fatalConversionError(to: Date.self, sqliteStatement: sqliteStatement, index: index)
            }
            self.init(timeIntervalSinceReferenceDate: date.timeIntervalSinceReferenceDate)
        default:
            fatalConversionError(to: Date.self, sqliteStatement: sqliteStatement, index: index)
        }
    }
}
public struct ATOMTapDataPoint {
}
extension SQLSpecificExpressible {
  public var asc: any SQLOrderingTerm {
    get
  }
  public var desc: any SQLOrderingTerm {
    get
  }
}
extension SQLSpecificExpressible {
  @available(*, deprecated, renamed: "forKey(_:)")
  public func aliased(_ name: Swift.String) -> any SQLSelectable
  public func forKey(_ key: Swift.String) -> any SQLSelectable
  @available(*, deprecated, renamed: "forKey(_:)")
  public func aliased(_ key: any Swift.CodingKey) -> any SQLSelectable
  public func forKey(_ key: any Swift.CodingKey) -> any SQLSelectable
}
extension SQLSpecificExpressible {
  public func collating(_ collation: Database.CollationName) -> SQLCollatedExpression
}
extension FetchableRecord where Self : Swift.Decodable {
  public init(row: Row)
}
extension EncodableRecord where Self : Swift.Encodable {
  public func encode(to container: inout PersistenceContainer)
}
@usableFromInline
internal struct OrderedDictionary<Key, Value> where Key : Swift.Hashable {
  @usableFromInline
  internal var keys: [Key]
  @usableFromInline
  internal var dictionary: [Key : Value]
  @usableFromInline
  internal subscript(key: Key) -> Value? {
    get
    set
  }
  @inlinable internal subscript(key: Key, default defaultValue: Value) -> Value {
    get { return dictionary[key] ?? defaultValue }
    set { self[key] = newValue }
  }
  @discardableResult
  @usableFromInline
  internal mutating func updateValue(_ value: Value, forKey key: Key) -> Value?
  @discardableResult
  @inlinable internal mutating func removeValue(forKey key: Key) -> Value? {
        guard let value = dictionary.removeValue(forKey: key) else {
            return nil
        }
        let index = keys.firstIndex { $0 == key }!
        keys.remove(at: index)
        return value
    }
}
extension OrderedDictionary : Swift.Collection {
  @usableFromInline
  internal typealias Index = Swift.Int
  @usableFromInline
  internal var startIndex: Swift.Int {
    get
  }
  @usableFromInline
  internal var endIndex: Swift.Int {
    get
  }
  @usableFromInline
  internal func index(after i: Swift.Int) -> Swift.Int
  @usableFromInline
  internal subscript(position: Swift.Int) -> (key: Key, value: Value) {
    get
  }
  @usableFromInline
  internal typealias Element = (key: Key, value: Value)
  @usableFromInline
  internal typealias Indices = Swift.DefaultIndices<OrderedDictionary<Key, Value>>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<OrderedDictionary<Key, Value>>
  @usableFromInline
  internal typealias SubSequence = Swift.Slice<OrderedDictionary<Key, Value>>
}
extension OrderedDictionary : Swift.ExpressibleByDictionaryLiteral {
  @usableFromInline
  internal init(dictionaryLiteral elements: (Key, Value)...)
}
extension OrderedDictionary : Swift.Equatable where Value : Swift.Equatable {
  @usableFromInline
  internal static func == (lhs: OrderedDictionary<Key, Value>, rhs: OrderedDictionary<Key, Value>) -> Swift.Bool
}
extension Foundation.NSURL : DatabaseValueConvertible {
  public var databaseValue: DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Self?
}
extension Foundation.URL : DatabaseValueConvertible {
}
public protocol SQLCollection {
  func collectionSQL(_ context: inout SQLGenerationContext) -> Swift.String
  func contains(_ value: any SQLExpressible) -> any SQLExpression
}
extension SQLCollection {
  public func contains(_ value: any SQLExpressible) -> any SQLExpression
}
public protocol DatabaseReader : AnyObject {
  var configuration: Configuration { get }
  func interrupt()
  func read<T>(_ block: (Database) throws -> T) throws -> T
  func asyncRead(_ block: @escaping (Swift.Result<Database, any Swift.Error>) -> Swift.Void)
  func unsafeRead<T>(_ block: (Database) throws -> T) throws -> T
  func unsafeReentrantRead<T>(_ block: (Database) throws -> T) throws -> T
}
extension DatabaseReader {
  public func backup(to writer: any DatabaseWriter) throws
}
final public class AnyDatabaseReader : DatabaseReader {
  public init(_ base: any DatabaseReader)
  final public var configuration: Configuration {
    get
  }
  final public func interrupt()
  final public func read<T>(_ block: (Database) throws -> T) throws -> T
  final public func asyncRead(_ block: @escaping (Swift.Result<Database, any Swift.Error>) -> Swift.Void)
  final public func unsafeRead<T>(_ block: (Database) throws -> T) throws -> T
  final public func unsafeReentrantRead<T>(_ block: (Database) throws -> T) throws -> T
  @objc deinit
}
extension SQLInterpolation {
  public mutating func appendInterpolation<T>(_ table: T.Type) where T : TableRecord
  public mutating func appendInterpolation<T>(tableOf record: T) where T : TableRecord
  public mutating func appendInterpolation(_ selection: any SQLSelectable)
  public mutating func appendInterpolation(_ expressible: any SQLExpressible & SQLOrderingTerm & SQLSelectable)
  public mutating func appendInterpolation(_ codingKey: any SQLExpressible & SQLOrderingTerm & SQLSelectable & Swift.CodingKey)
  public mutating func appendInterpolation(_ expressible: (any SQLExpressible)?)
  public mutating func appendInterpolation(_ codingKey: any Swift.CodingKey)
  public mutating func appendInterpolation<T>(_ expressible: T) where T : SQLExpressible, T : Swift.Sequence, T.Element : SQLExpressible
  public mutating func appendInterpolation<S>(_ sequence: S) where S : Swift.Sequence, S.Element : SQLExpressible
  public mutating func appendInterpolation<S>(_ sequence: S) where S : Swift.Sequence, S.Element == any SQLExpression
  public mutating func appendInterpolation(_ ordering: any SQLOrderingTerm)
  public mutating func appendInterpolation<T>(_ request: SQLRequest<T>)
}
@_hasMissingDesignatedInitializers final public class ATOMFlushManager {
  public static let shared: ATOMFlushManager
  final public func startTracking(_ elements: [ATOMFlush])
  final public func stopTracking()
  @objc deinit
}
extension Database.CheckpointMode : Swift.Equatable {}
extension Database.CheckpointMode : Swift.Hashable {}
extension Database.CheckpointMode : Swift.RawRepresentable {}
extension Database.ConflictResolution : Swift.Equatable {}
extension Database.ConflictResolution : Swift.Hashable {}
extension Database.ConflictResolution : Swift.RawRepresentable {}
extension Database.ForeignKeyAction : Swift.Equatable {}
extension Database.ForeignKeyAction : Swift.Hashable {}
extension Database.ForeignKeyAction : Swift.RawRepresentable {}
extension Database.TransactionCompletion : Swift.Equatable {}
extension Database.TransactionCompletion : Swift.Hashable {}
extension Database.TransactionKind : Swift.Equatable {}
extension Database.TransactionKind : Swift.Hashable {}
extension Database.TransactionKind : Swift.RawRepresentable {}
extension ATOMConsentError : Swift.Equatable {}
extension ATOMConsentError : Swift.Hashable {}
extension DatabaseUUIDEncodingStrategy : Swift.Equatable {}
extension DatabaseUUIDEncodingStrategy : Swift.Hashable {}
extension ATOMGesturesList : Swift.Equatable {}
extension ATOMGesturesList : Swift.Hashable {}
extension ATOMGesturesList : Swift.RawRepresentable {}
extension ATOMConfigurationError : Swift.Hashable {}
extension HTTPMethod : Swift.Equatable {}
extension HTTPMethod : Swift.Hashable {}
extension HTTPMethod : Swift.RawRepresentable {}
extension Database.TransactionObservationExtent : Swift.Equatable {}
extension Database.TransactionObservationExtent : Swift.Hashable {}
extension DatabaseEvent.Kind : Swift.Equatable {}
extension DatabaseEvent.Kind : Swift.Hashable {}
extension DatabaseEvent.Kind : Swift.RawRepresentable {}
@available(*, unavailable, renamed: "Connection")
extension ATOMReachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Connection")
extension ATOMReachability.NetworkStatus : Swift.Hashable {}
extension ATOMReachability.Connection : Swift.Equatable {}
extension ATOMReachability.Connection : Swift.Hashable {}
extension ATOMFeatureState : Swift.Equatable {}
extension ATOMFeatureState : Swift.Hashable {}
extension DatabaseDateComponents.Format : Swift.Equatable {}
extension DatabaseDateComponents.Format : Swift.Hashable {}
extension DatabaseDateComponents.Format : Swift.RawRepresentable {}
extension ATOMCellularConnectionType : Swift.Equatable {}
extension ATOMCellularConnectionType : Swift.Hashable {}
extension ZipError : Swift.Equatable {}
extension ZipError : Swift.Hashable {}
extension ZipCompression : Swift.Equatable {}
extension ZipCompression : Swift.Hashable {}
extension ZipCompression : Swift.RawRepresentable {}
